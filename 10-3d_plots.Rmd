# 3D color plots

You may want to plot your data as a color map, like the evolution of a Raman spectrum as a function of temperature, pressure or position. In some cases you'll have a 3-columns `data.frame` with x, y, and z values (_e.g._ intensity of a peak as a function of the position on the sample), in some cases you can have a list of spectra evolving with a given parameter. 

## The ggplot2 solution

Let's create a dummy set of spectra that we will gather in a tidy `tibble`.

```{r, message=FALSE}
Nspec <- 40                           # Amount of spectra
T     <- seq(273, 500, length=Nspec)  # Fake Temperatures
N     <- 500                          # Size of the x vector
library(tidyverse)
library(ggplot2)
library(plotly)
fake_data <- tibble()                 # Empty tibble
for (i in 1:Nspec) {
    # Let's create dummy x and y values
    # You would normally use a read.table here 
    x  <- seq(0, 100, length = N)
    y  <- 50*dnorm(x, mean= (T[i]/T[1])*20 + 25, sd = 10+runif(1,max=5) )
    fake_data <- bind_rows(fake_data, 
                           tibble(w=x, Intensity=y, T=T[i]) 
                           )
}
fake_data
```

OK, so now we have some fake experimental data stored in a tidy `tibble` called `fake_data`. We want to plot it as a color map in order to grasp the evolution of the spectra:

```{r, out.width='100%', message = FALSE, fig.asp=.7,cache=FALSE}
# Plotting
colors <- colorRampPalette(c("white","royalblue","seagreen",
                             "orange","red","brown"))(500)
P1 <- ggplot(data=fake_data, aes(x=w, y=T, fill=Intensity)) + 
          geom_raster() + #geom_tile would work
          ggtitle("Some fake data") + 
          scale_fill_gradientn(colors=colors,name="Intensity\n[arb. units]") +
          labs(x = "Fake Raman Shift [1/cm]",y="Fake Temperature [K]") +
          theme_bw()
ggplotly(P1, dynamicTicks = TRUE)
# Some other way : a stacking of plots 
colors <- colorRampPalette(c("royalblue","seagreen","orange",
                             "red","brown"))(length(T))
fake_data$T_round <- round(fake_data$T,1)
P2 <- ggplot(data=fake_data, 
                aes(x=w, 
                    y=Intensity+as.numeric(factor(T))-1,
                    color = factor(T_round), group = T, 
                    text = paste("w =",round(w,3),
                               "<br>Int =",round(Intensity,3),
                               "<br>T =",round(T,3))
                    )
                ) + 
          geom_line() + 
          labs(x="Fake Raman Shift [1/cm]", y="Fake Intensity [arb. units]") +
          coord_cartesian(xlim = c(25,75)) +
          scale_color_manual(values=colors,name="Fake\nTemperature [K]") +
          theme_bw()
ggplotly(P2, tooltip = "text", dynamicTicks = TRUE)
P3 <- ggplot(data=fake_data, 
                aes(x=w, 
                    y=Intensity+as.numeric(factor(T))-1, 
                    color=T, group=T,
                    text=paste("w =",round(w,3),
                               "<br>Int =",round(Intensity,3),
                               "<br>T =",round(T,3)))) + 
          geom_line() + 
          labs(x="Fake Raman Shift [1/cm]", y="Fake Intensity [arb. units]") +
          scale_color_gradientn(colors=colors,name="Fake\nTemperature [K]") +
          coord_cartesian(xlim = c(25,75)) +
          theme_bw()
ggplotly(P3, tooltip = "text", dynamicTicks = TRUE)
```



## The base graphics solution

In some cases you end up with a matrix _z_, and two vectors _x_ and _y_. This is easy to plot using the base `image` function. For the sake of example, let's just use the `acast` function on our melted 3-columns data.frame:

```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.6,cache=FALSE}
library(reshape2)
z <- acast(data.frame(fake_data), x~T, value.var="Intensity")
x <- unique(data.frame(fake_data)[,"w"])
y <- unique(data.frame(fake_data)[,"T"])
x <- x[order(x)]
y <- y[order(y)]
colors <- colorRampPalette(c("white","royalblue","seagreen","orange","red","brown"))(500)
par(mar=c(4, 4, .5, 4), lwd=2)
image(x,y,z,col = colors)
```
You can add a legend by using the `image.plot` function:
```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.6,cache=FALSE}
library(fields)
par(mar=c(4, 4, .5, 4), lwd=2)
image.plot(x,y,z, col = colors)
```


## The plotly solution

And finally, if you want to make this an interactive plot, you can use `plotly`:
```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.6,cache=FALSE}
library(plotly)
aX <- list(title = "Raman Shift [1/cm]")
aY <- list(title = "Temperature [K]")
# Weird but you need to use t(z) here:
z <- t(z)
# Color plot
plot_ly(x=x,y=y,z=z,type = "heatmap",colors=colors) %>% 
   layout(xaxis = aX, yaxis = aY)
```
Or, very cool, an interactive surface plot:
```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.9,cache=FALSE}
plot_ly(x=x,y=y,z=z,type = "surface",colors=colors) %>%
   layout(scene = list(xaxis = aX, yaxis = aY, dragmode="turntable"))
```


## 2D density of points

In case you want to plot a density of points, you have a variety of solutions:
```{r}
df <- tibble(x=rnorm(1e3, mean=c(1,5)),
             y=rnorm(1e3, mean=c(5,1)))
p1 <- ggplot(data=df, aes(x=x,y=y))+ geom_density2d() + ggtitle('geom_density2d()')
p2 <- ggplot(data=df, aes(x=x,y=y))+ geom_hex() + ggtitle('geom_hex()')
p3 <- ggplot(data=df, aes(x=x,y=y))+ geom_bin2d() + ggtitle('geom_bin2d()')
p4 <- ggplot(data=df, aes(x=x,y=y))+ ggtitle('stat_density2d()') +
        stat_density2d(aes(fill = ..density..), geom = "tile", contour = FALSE, n = 200) +
        scale_fill_continuous(low = "white", high = "dodgerblue4")
library(cowplot)
plot_grid(p1,p2,p3,p4)
```


Or the base `smoothScatter()` function could do the trick:
```{r}
smoothScatter(df)
```





