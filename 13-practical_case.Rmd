# Practical case: recursive data treatment

## Example {#example-practical}


Here I will provide an example workflow for treating large amounts of experimental measurements. There are many ways of doing this, this is just a working example. 

You will find <a href="https://github.com/colinbousige/Rclass/raw/master/Data/XPdata.zip" download target="_blank">here</a> the corresponding experimental data.

My way of doing things – again, maybe not the best, but it's what I do – is that for each experiment I create a folder containing at least 4 objects:

- `log.Rmd`: the markdown or R notebook in which I treat the data. I can produce a pdf or html document from it. We will see about that in the next section.
- `myfunc.R`: my user-defined functions that I can load in my working environment using `source(myfunc.R)`
- `Data/`: folder containing the original data (usually ASCII files) that I _never modify_ (reproducible data treatment and all that)
- `Plots/`: folder containing the static (pdf) plots produced with `log.Rmd`

So, let's begin. First we set up our working environment:

```{r, warnings=FALSE, message=FALSE}
# Load the needed libraries and define some functions
library(ggplot2)
library(tidyverse)
library(plotly)
# Load some user-defined functions (Pruby)
source("myfunc.R")
# Normalized Lorentzian function
Lor <- function(x,x0=0,FWHM=1){
    2/(pi*FWHM)/( 1 + ((x-x0)/(FWHM/2))^2 )
}
```

In the working directory, we create a folder `Data` in which we extract the <a href="https://github.com/colinbousige/Rclass/raw/master/Data/XPdata.zip" download target="_blank">XPdata.zip</a> archive. It contains a number of txt files named `rubis_XX.txt`. They are Raman spectra of ruby chips under pressure used for the calibration of pressure in a diamond anvil cell, their shift is directly correlated to the pressure in the DAC.

First, let's list all these files:
```{r, warning=FALSE}
# Find all the files in "Data"
frubis <- list.files(path="Data", pattern = "rubis")
head(frubis)
length(frubis)
# Create a tibble to store each spectra
spec   <- tibble()
# and a tibble to store the fit parameters
fitpar <- tibble()
```

Now let's read the data, store them in the tibble `spec` together with other informations, such as the name of the file, the fitted curves of the peaks, or the obtained pressure (the function `Pruby()` is defined in `myfunc.R`).

```{r, out.width='100%', fig.asp=.85, cache=FALSE, warning=FALSE, message=FALSE}
# Reading and storing all treated data 
for(file in frubis){
    # Reading raw data to a tibble
    d <- read_table2(file.path("Data",file), 
                  col_names = c("w", "Int") )
    # Fitting two Lorentzians using the previously defined function Lor()
    # Initial guess of the position and parameters:
    xmax  <- d$w[which.max(d$Int)] 
    Guess <- c(y0   = 0.01,               # constant background
               x    = c(xmax-2, xmax-30), # positions
               FWHM = c(10, 10),          # full width at half maximum
               A    = c(max(d$Int), max(d$Int))*10 # amplitudes
               )
    fit <- nls(data  = d, Int ~ y0 + A1*Lor(w,x1,FWHM1) + A2*Lor(w,x2,FWHM2), 
               start = as.list(Guess), 
               lower = as.list(Guess*0),
               algorithm = "port"
           )
    # Compute the various components of the fit
    p  <- coef(fit)
    y0 <- p['y0']
    y1 <- p['A1']*Lor(d$w, x0=p['x1'], FWHM=p['FWHM1'])
    y2 <- p['A2']*Lor(d$w, x0=p['x2'], FWHM=p['FWHM2'])
    ytot <- y0 + y1 + y2
    # Store all the data and fits in a tidy tibble
    spec <- bind_rows(spec, 
                tibble(w      = d$w,
                       Int    = d$Int, 
                       Int_n  = d$Int/max(d$Int), 
                       y1_n   = y1/max(d$Int),
                       y2_n   = y2/max(d$Int),
                       ytot_n = ytot/max(d$Int),
                       name   = gsub(".txt","",file),
                       P      = round(Pruby(p['x1']),2)
                       )
            )
    # Store the fitting parameters in a tidy data.frame
    fitpar <- bind_rows(fitpar, 
                broom::tidy(fit) %>% 
                    select(term,estimate,std.error) %>% 
                    mutate(name = gsub(".txt","",file),
                           P    = round(Pruby(p['x1']),2))
              )
    # Uncomment and plot to check if everything is OK:
    # spec %>% filter(name==gsub(".txt","",file)) %>% 
    # ggplot(aes(x=w)) +
    #   ggtitle(file)+
    #   geom_point(aes(y=Int))+
    #   geom_line(aes(y=ytot),color="red")+
    #   geom_area(aes(y=y1),fill="orange", alpha=0.1)+
    #   geom_area(aes(y=y2),fill="royalblue", alpha=0.1)+
    #   theme_bw()
}
```

Now let's take a global look at our data. For this I like the slider functionality of `plotly`. Make your `ggplot` as usual, and just add the keyword `frame` that is read by `ggplotly()`:

```{r, out.width='100%', fig.asp=.85, cache=FALSE, warning=FALSE, message=FALSE}
gg <- ggplot(data=spec,aes(x=w)) +
          labs(x="Raman Shift [1/cm]", y="Intensity [arb. units]")+
          geom_point(aes(y=Int_n, frame=P))+
          geom_line(aes(y=ytot_n, frame=P),color="red")+
          geom_line(aes(y=y1_n, frame=P),color="royalblue", alpha=0.5)+
          geom_line(aes(y=y2_n, frame=P),color="orange", alpha=0.5)+
          theme_bw()
ggplotly(gg, dynamicTicks = TRUE) %>%
  animation_opts(5)%>%
  layout(xaxis = list(autorange=FALSE, range = c(3050, 3550)))%>%
  animation_slider(
    currentvalue = list(prefix = "Pressure: ", 
                        suffix = " GPa", font = list(color="red"))
  )
```

<br>
In case you want to save all the plots in a pdf file, you'd do something like that:

```r
pdf("Plots/plots_fits.pdf",height=6, width=8)
for(file in frubis){
    p <- spec %>% filter(name==gsub(".txt","",file)) %>% 
         ggplot(aes(x=w)) +
            geom_point(aes(x=w,y=Int))+
            labs(x="Raman Shift [1/cm]", y="Intensity [arb. units]")+
            ggtitle(gsub(".txt","",file))+
            geom_line(aes(y=ytot),color="red")+
            geom_area(aes(y=y1),fill="orange", alpha=0.1)+
            geom_area(aes(y=y2),fill="royalblue", alpha=0.1)+
            theme_bw()
    print(p)
}
dev.off()
```

where the line `print(p)` is necessary, since `ggplot` does not output plots when embedded in a for loop.

Now we can also plot the evolution of the fit parameters. Let's only look at the position of the peaks and the error on the fit:

```{r, out.width='100%', fig.asp=.85,cache=FALSE, warning=FALSE, message=FALSE}
p <- fitpar %>% filter(grepl('x', term)) %>% 
        ggplot(aes(x=name, y=estimate, color=term)) +
            scale_color_manual(values = c('black','red'))+
            geom_point(size=2)+
            geom_errorbar(aes(ymin=estimate-std.error, 
                              ymax=estimate+std.error),
                          width=.5)+
            theme_bw() +
            theme(axis.text.x = element_text(angle = 45, hjust=1))
ggplotly(p, dynamicTicks = TRUE)
```

And *voilà*! in a few lines of code, you have treated a number of spectra in the same manner, plotted the fits, obtained the fitting parameters and deducted the corresponding pressure.

You are now ready to get to work!














## Exercise

Try to do something similar but in a full `tidyverse` way, *i.e.* without doing any `for loop`. For this, look into `purrr::map(data, function)` and do something similar to this:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
library(tidyverse)
tibble(world = c("Hello","world")) %>% 
    mutate(to_print=map(world, ~ gsub("o", "a", .))) %>% 
    unnest(to_print)
```

<details>
    <summary>Solution</summary>


```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
# Load the needed libraries and define some functions
library(tidyverse)
library(ggplot2)
library(broom)
library(plotly)
source("myfunc.R")
Lor <- function(x,x0=0,FWHM=1){
    2/(pi*FWHM)/( 1 + ((x-x0)/(FWHM/2))^2 )
}
# Find all files
frubis <- list.files(path="Data", pattern = "rubis")
# Load all data and do the fits in a single pipe flow
data <- tibble(name = frubis) %>%
    mutate(data = purrr::map(name,
           ~ read_table2(file      = file.path("Data", .),
                         col_names = c("w", "Int")))
        ) %>% 
    mutate(fit = purrr::map(data, 
        ~ nls(data = .,
              Int ~ y0 + A1*Lor(w,x1,FWHM1) + A2*Lor(w,x2,FWHM2), 
              start=list(y0 = 0.01,
                         x1 = .$w[which.max(.$Int)] - 2,
                         x2 = .$w[which.max(.$Int)] - 30,
                         FWHM1 = 10,
                         FWHM2 = 10,
                         A1    = max(.$Int)*10,
                         A2    = max(.$Int)*10),
              lower = list(y0 = 0, 
                           x1 = 0, x2 = 0,
                           FWHM1 = 0, FWHM2 = 0,
                           A1 = 0, A2 = 0),
              algorithm = "port")),
          tidied = purrr::map(fit, tidy),
          augmented = purrr::map(fit, augment)
          ) %>% 
    mutate(P=purrr::map(tidied, 
            ~round(Pruby(.$estimate[.$term=='x1']),2))) %>% 
    unnest(P)
# make the plot of the fits
P <- data %>% 
    unnest(augmented) %>% 
    group_by(name) %>% 
    mutate(Int_n=Int/max(Int), 
           .fitted_n=.fitted/max(Int)) %>% 
    ggplot(aes(x=w, frame=P))+
        geom_point(aes(y=Int_n), alpha=.3)+
        geom_line(aes(y=.fitted_n), color="red")
ggplotly(P, dynamicTicks = TRUE) %>% 
    animation_opts(5)%>%
      layout(xaxis = list(autorange=FALSE, range = c(3050, 3550)))%>%
      animation_slider(
        currentvalue = list(prefix = "Pressure: ", 
                            suffix = " GPa", font = list(color="grey"))
      )
```


</details>