# Data frames

## Defining a data.frame


In R, the principal object is *the data*. Hence the `data.frame` object, which is basically a table of vectors. A `data.frame` is a list presented under the form of a table – *i.e.* a spreadsheet. On a day-to-day basis, you will either define `data.frame` from existing vectors or other `data.frame`, or define a `data.frame` from a file (text, Excel...). In this example, we use <a href="Data/test.dat" download target="_blank">test.dat</a> and <a href="Data/test.xlsx" download target="_blank">test.xlsx</a>.

```{r, warnings=FALSE, message=FALSE}
# x = 10 random numbers between -10 and 10
x  <- runif(10, min=-10, max=10) 
y  <- sin(x)
df <- data.frame(x,y) # df is a data.frame (a table)
df
# dimension of df
dim(df);nrow(df);ncol(df)
# first and last 3 values
head(df, 3); tail(df, 3)
# information on df
str(df)
# statistics on df
summary(df)
# changing column name
df <- data.frame(xxx=x,yyy=y)
head(df,2)
names(df) <- c("thisISx","THISisY")
head(df,2)
# from a matrix
A <- matrix(1:9,ncol=3)
as.data.frame(A)
# from a file
read.table("Data/test.dat")            # default column name is V1, V2, V3, etc
read.table("Data/test.dat",header=TRUE)# use first line as column names
read.table("Data/test.dat",skip=1)     # skip first line. 
# ?read.table for more options
library(readxl) # load readxl from tidyverse to read Excel files
read_excel("Data/test.xlsx", sheet=1)
read_excel("Data/test.xlsx", sheet=2)
```

## Accessing values 

```{r, warnings=FALSE}
# column number
df[,1] # this is a vector
df[[1]]# this is a vector too
# column name
df$thisISx; df[,"THISisY"] # a vector too
# first row; row 1 to 3
df[1,]; df[1:3,]
# through conditions
df[x<0 & y>0, ]  # Here x and y are vectors, not the column names
df[ df[,"thisISx"]<0 & df[,2]>0, ]  # conditions on columns
# subsetting using column names
subset(df, thisISx>2 & THISisY>0)
subset(df, thisISx>2 & THISisY>0, select = c(thisISx))
```

## Adding columns or rows

```{r, warnings=FALSE}
# Adding columns
df   <- data.frame(x,y)
df$z <- (df$x)^2; df
data.frame(df,w=1:length(x), xx=NA, yy=1, zz=1:2)
cbind(df, data.frame(a=1:length(x), b=1:length(x)) )
# Adding rows
rbind(df, df)     # with a data.frame
rbind(df, 1:2)    # with a vector
# deleting rows/columns
df[-1,]
df[,-1]
```

## Tidy up!


### What is tidy data?

**A good practice in R is to *tidy* your data.** R follows a set of conventions that makes one layout of tabular data much easier to work with than others. Your data will be easier to work with in R if it follows three rules:

- Each variable in the data set is placed in its own column
- Each observation is placed in its own row
- Each value is placed in its own cell

Data that satisfies these rules is known as tidy data. Example:

```r
df <- read.csv("Data/population.csv")
df # is not tidy
```
<details>
    <summary>Show output</summary>

```{r echo=FALSE}
df <- read.csv("Data/population.csv")
df # is not tidy
```

</details>

```r
library(tidyr)
df <- pivot_longer(df, cols=-Année, names_to="city", values_to="pop")
df #is tidy
```

<details>
    <summary>Show output</summary>

```{r echo=FALSE, message=FALSE}
library(tidyr)
df <- pivot_longer(df, cols=-Année, names_to="city", values_to="pop")
df #is tidy
```

</details>

```r
# is not tidy
pivot_wider(df, names_from="city", values_from="pop")
```
<details>
    <summary>Show output</summary>

```{r echo=FALSE}
# is not tidy
pivot_wider(df, names_from="city", values_from="pop")
```

</details>

</details>


You can find more information on data import and [tidyness](https://garrettgman.github.io/tidying/) on the [data-import cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf) and on the [tidyr](http://www.sthda.com/english/wiki/tidyr-crucial-step-reshaping-data-with-r-for-easier-analyses) package.


### Tibbles

A `tibble` is an enhanced version of the `data.frame` provided by the `tidyverse` package. The main advantage of `tibble` is that it has easier initialization and nicer printing than `data.frame`, and the performance are also enhanced – especially for the reading from files with `read_delim()`, `read_tsv()` and `read_csv()`. Otherwise, the handling is basically the same.

More on tibbles [here](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html).

```{r, include=FALSE}
rm(x)
```

```{r, error=TRUE, warnings=FALSE, message=FALSE}
library(tidyverse)
( tib <- tibble(x=runif(1e3), y=cumsum(x)) )
data.frame(x=runif(1e3), y=cumsum(x))
# ATTENTION subsetting
# Tibbles are quite strict about subsetting. [ always returns another tibble. 
# Contrast this with a data frame: sometimes [ returns a data frame and sometimes it just returns a vector:
head(tib[[1]]) # is a vector
head(tib[,1])  # is a tibble
```

### Data tables

A `data.table`, much like a tibble, is an enhanced version of the `data.frame` provided by the [data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html) package. In case you have very large files to read and do statistics upon, consider using it in conjunction with `fread()` in preference to `data.frames` and `read.table()`.


## Operations in the tidyverse

In the end, base R and the `tidyverse` package provide many efficient functions to perform most of the tasks you would want to perform recursively, thus allowing avoiding explicit for loops.

Here are some examples, and you will find much more [here](https://dplyr.tidyverse.org/). Note the use of the pipe operator, `%>%`, that allows a clear syntax for successive operations:

```{r, message=FALSE}
# create a random tibble
library(tidyverse)
N <- 500
dt <- tibble(x     = rep(runif(N,-1,1),3), 
             y     = runif(N*3,-1,1), 
             signx = ifelse(x>0,"positive","negative"),
             signy = ifelse(y>0,"positive","negative")
)
dt
# means/sd by groups of another variable
dt %>% 
    group_by(signx) %>% 
    summarise(mean_x = mean(x), 
              sd_x   = sd(x)
             )
dt %>% 
    group_by(signx, signy) %>% 
    summarise(mean_x=mean(x), mean_y=mean(y))
# sorting
dt %>% arrange(x)
dt %>% arrange(x, desc(y))
# merge table information
dt2 <- tibble(signx=c("positive","positive","negative","negative"), 
              signy=c("positive","negative","positive","negative"), 
              value=c(TRUE, FALSE, FALSE, TRUE))
dt2
inner_join(dt,dt2)
# add/modify a column
dt %>% mutate(w=seq_along(x), z=sin(x))
dt %>% mutate(x=seq_along(x))
# selecting columns
dt %>% select(starts_with("sign"))
dt %>% select(contains("x"))
dt %>% select(x)  # only x
dt %>% select(-x) # all but x
# filtering columns
dt %>% filter(signx=="positive")
dt %>% filter(x<0, y>.1)
# providing data to ggplot
library(ggplot2)
dt %>% filter(abs(y)> 0.1) %>% 
    ggplot(aes(x=x, y=y, color=signy))+
        geom_point()
```


## Exercises

<details>
<summary>**Exercise 1**</summary>

- Create a 3 column `data.frame` containing 100 random values, their sinus, and the sum of the two first columns.
- Do the same with a `tibble`
- Look into the function `write.table` to write a text file containing this `data.frame`

</details>


<details>
    <summary>**Exercise 2**: `data.frame` from a "complicated" data file</summary>

- Download the TGA data file <a href="Data/ATG.txt" download target="_blank">ATG.txt</a>
- Load it into a `data.frame`. Look into the options of `read.table` to get the proper data fields.

<details>
    <summary>Solution</summary>

```{r}
d <- read.table("Data/ATG.txt", 
                skip=12,
                header=FALSE, 
                nrows=4088)
names(d) <- c("Index", "t", "Ts", "Tr", "Value")
head(d)
d <- read.table("Data/ATG.txt", 
                skip=10,
                comment.char="[",
                header=TRUE, 
                nrows=4088)
head(d)
```

</details>
</details>


<details>
    <summary>**Exercise 3**</summary>

- Create a `data.frame` (or a `tibble`) called `people` from <a href="Data/people.txt" download target="_blank">people.txt</a>. Try using the function `read.table` or its `tidyverse` equivalent `read_table2`.
- What are the column names of `people`?
- Add a column `age` and fill it with the appropriate values
    + *Bonus Tip:* to interactively enter the data, look into the function `readline()` and try making a `for` loop
- What is the average age of the class?
- How many students are in the class?
- What is the percentage of female/male students in the class?
- Get the columns 1 and 3
- Print `people` where you removed the rows 1, 5 and 6
- Get the columns of `age` and `origin` in another `data.frame`
- Subset `people` to get the list of people from China and Ukraine in one `data.frame`
- How many students come from the USA? from France?
- Order the `data.frame` `people` by student name
- Order the `data.frame` `people` by country of origin and then by age
- Select 5 random students from `people`
- Using the `tidyverse`, get the average age of females and males in the class in a `tibble`

</details>



<details>
<summary>**Exercise 4**</summary>

Download <a href="Data/population.txt" download target="_blank">population.txt</a> and load it into a `data.frame`.

- Are the data tidy?
- What are the names of the columns?
- Create a subset containing the data for Montpellier
    + What is the max and min of population in this city?
    + The average population over time?
- What is the total population in 2012?
- What is the total population per year?
- What is the average population per city over the years?

<details>
<summary>Solution</summary>

```{r}
# Download population.txt and load it into a `data.frame`.
popul <- read.table("Data/population.txt", header=TRUE)
# Are the data tidy?
head(popul) # yes
# What are the names of the columns and the dimension of the table?
names(popul); dim(popul)
# Create a subset containing the data for Montpellier
mtp <- subset(popul, city == "Montpellier")
# I prefer the tidyverse version
library(tidyverse)
mtp <- popul %>% filter(city == "Montpellier")
# What is the max and min of population in this city?
max(mtp$pop)
min(mtp$pop)
range(mtp$pop)
# The average population over time?
mean(mtp$pop)
# What is the total population in 2012?
sum(popul[popul$year == 2012, "pop"])
popul %>% 
    filter(year==2012) %>% 
    select(pop) %>% 
    sum()
# What is the total population per year?
popul %>% 
    group_by(year) %>% 
    summarise(pop_tot=sum(pop))
# What is the average population per city over the years?
popul %>% 
    group_by(city) %>% 
    summarise(pop_ave=mean(pop))
```

</details>
</details>



<details>
    <summary>**Exercise 5:** tidy data wrangling</summary>

- First, load the `tidyverse` and `lubridate` package
- Load <a href="Data/people1.csv" download target="_blank">people1.csv</a> and <a href="Data/people2.csv" download target="_blank">people2.csv</a> into `pp1` and `pp2`
- Create a new tibble `pp` by using the pipe operator (`%>%`) and successively:
    - joining the two tibbles into one using `inner_join()`
    - adding a column `age` containing the age in years (use lubridate's `time_length(x, 'years')` with x a time difference in days) by using `mutate()`
- Display a summary of the table using `str()`
- Using `groupe_by()` and `summarize()`:
    - Show the number of males and females in the table (use the counter `n()`)
    - Show the average age per gender
    - Show the average size per gender and institution
    - Show the number of people from each country, sorted by descending population (`arrange()`)
- Using `select()`, display:
    - only the name and age columns
    - all but the name column
- Using `filter()`, show data only for
    - Chinese people
    - From institution ECL and UCBL
    - People older than 22 
    - People with a `e` in their name

<details>
    <summary>Solution</summary>

```{r, warnings=FALSE, message=FALSE}
# First, load the `tidyverse` and `lubridate` package
library(tidyverse)
library(lubridate)
# Load people1.csv and people2.csv
pp1  <- read_csv("Data/people1.csv")
pp2  <- read_csv("Data/people2.csv")
# Create a new tibble `pp` by using the pipe operator (`%>%`)
# and successively:
# - joining the two tibbles into one using `inner_join()`
# - adding a column `age` containing the age in years 
#   (use lubridate's `time_length(x, 'years')` with x a time
#   difference in days) by using `mutate()`
pp <- pp1 %>% 
        inner_join(pp2) %>% 
        mutate(age=time_length(today()-dateofbirth,'years'))
# Display a summary of the table using `str()`
str(pp)
# Using `groupe_by()` and `summarize()`:
# - Show the number of males and females in the table 
#   (use the counter `n()`)
pp %>% group_by(gender) %>% summarize(count=n())
# - Show the average age per gender
pp %>% group_by(gender) %>% summarize(age=mean(age))
# - Show the average size per gender and institution
pp %>% group_by(gender, institution) %>% summarize(size=mean(size))
# - Show the number of people from each country, 
#   sorted by descending population
pp %>% group_by(origin) %>% 
        summarize(count=n()) %>% 
        arrange(desc(count))
# Using `select()`, display:
# - only the name and age columns
pp %>% select(c(name, age))
# - all but the name column
pp %>% select(-name)
# Using `filter()`, show data only for
# - Chinese people
pp %>% filter(origin=='China')
# - From institution ECL and UCBL
pp %>% filter(institution %in% c('ECL', 'UCBL'))
# - People older than 22 
pp %>% filter(age>22)
# - People with a `e` in their name
pp %>% filter(grepl('e',name))
```


</details>
</details>

For more interesting exercises in the tidyverse, look at:

- [CO2 emissions: data wrangling and ggplot2](Exo/Rexercises-co2.html)
- [Religion and babies: data handling, ggplot2 and plotly](Exo/Rexercises-religion_babies.html)
- [COVID-19: data wrangling, ggplot2](Exo/Rexercises-covid.html)

<br>
<br>
<br>
<br>
<br>





<br>
<br>
<br>
<br>
<br>


