# Data frames

## Defining a data.frame


In R, the principal object is *the data*. Hence the `data.frame`{.R} object, which is basically a table of vectors. A `data.frame`{.R} is a list presented under the form of a table – *i.e.* a spreadsheet. On a day-to-day basis, you will either define `data.frame`{.R} from existing vectors or other `data.frame`{.R}, or define a `data.frame`{.R} from a file (text, Excel...). In this example, we use <a href="Data/test.dat" download target="_blank">test.dat</a> and <a href="Data/test.xlsx" download target="_blank">test.xlsx</a>.

```{r, warnings=FALSE, message=FALSE}
# x = 10 random numbers between -10 and 10
x  <- runif(10, min=-10, max=10) 
y  <- sin(x)
df <- data.frame(x,y) # df is a data.frame (a table)
df
# dimension of df
dim(df);nrow(df);ncol(df)
# first and last 3 values
head(df, 3); tail(df, 3)
# information on df
str(df)
# statistics on df
summary(df)
# changing column name
df <- data.frame(xxx=x,yyy=y)
head(df,2)
names(df) <- c("thisISx","THISisY")
head(df,2)
# from a matrix
A <- matrix(1:9,ncol=3)
as.data.frame(A)
# from a file
read.table("Data/test.dat")            # default column name is V1, V2, V3, etc
read.table("Data/test.dat",header=TRUE)# use first line as column names
read.table("Data/test.dat",skip=1)     # skip first line. 
# ?read.table for more options
library(readxl) # load readxl from tidyverse to read Excel files
read_excel("Data/test.xlsx", sheet=1)
read_excel("Data/test.xlsx", sheet=2)
```

## Accessing values 

```{r, warnings=FALSE}
# column number
df[,1] # this is a vector
df[[1]]# this is a vector too
# column name
df$thisISx; df[,"THISisY"] # a vector too
# first row; row 1 to 3
df[1,]; df[1:3,]
# through conditions
df[x<0 & y>0, ]  # Here x and y are vectors, not the column names
df[ df[,"thisISx"]<0 & df[,2]>0, ]  # conditions on columns
# subsetting using column names
subset(df, thisISx>2 & THISisY>0)
subset(df, thisISx>2 & THISisY>0, select = c(thisISx))
```

## Adding columns or rows

```{r, warnings=FALSE}
# Adding columns
df   <- data.frame(x,y)
df$z <- (df$x)^2; df
data.frame(df,w=1:length(x), xx=NA, yy=1, zz=1:2)
cbind(df, data.frame(a=1:length(x), b=1:length(x)) )
# Adding rows
rbind(df, df)     # with a data.frame
rbind(df, 1:2)    # with a vector
# deleting rows/columns
df[-1,]
df[,-1]
```

## Tidy up!


### What is tidy data?

**A good practice in R is to *tidy* your data.** R follows a set of conventions that makes one layout of tabular data much easier to work with than others. Your data will be easier to work with in R if it follows three rules:

- Each variable in the data set is placed in its own column
- Each observation is placed in its own row
- Each value is placed in its own cell

Data that satisfies these rules is known as tidy data. Example:

```r
df <- read.csv("Data/population.csv")
df # is not tidy
```
<details>
    <summary>Show output</summary>

```{r echo=FALSE}
df <- read.csv("Data/population.csv")
df # is not tidy
```

</details>

```r
library(tidyr)
df <- pivot_longer(df, cols=-year, names_to="city", values_to="pop")
df #is tidy
```

<details>
    <summary>Show output</summary>

```{r echo=FALSE, message=FALSE}
library(tidyr)
df <- pivot_longer(df, cols=-year, names_to="city", values_to="pop")
df #is tidy
```

</details>

```r
# is not tidy
pivot_wider(df, names_from="city", values_from="pop")
```
<details>
    <summary>Show output</summary>

```{r echo=FALSE}
# is not tidy
pivot_wider(df, names_from="city", values_from="pop")
```

</details>

</details>


You can find more information on data import and [tidyness](https://garrettgman.github.io/tidying/) on the [data-import cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf) and on the [tidyr](http://www.sthda.com/english/wiki/tidyr-crucial-step-reshaping-data-with-r-for-easier-analyses) package.


### Tibbles

A `tibble`{.R} is an enhanced version of the `data.frame`{.R} provided by the `tidyverse` package. The main advantage of `tibble`{.R} is that it has easier initialization and nicer printing than `data.frame`{.R}, and the performance are also enhanced – especially for the reading from files with `read_delim()`{.R}, `read_tsv()`{.R} and `read_csv()`{.R}. Otherwise, the handling is basically the same.

More on tibbles [here](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html).

```{r, include=FALSE}
rm(x)
```

```{r, error=TRUE, warnings=FALSE, message=FALSE}
library(tidyverse)
( tib <- tibble(x=runif(1e3), y=cumsum(x)) )
data.frame(x=runif(1e3), y=cumsum(x))
# ATTENTION subsetting
# Tibbles are quite strict about subsetting. [ always returns another tibble. 
# Contrast this with a data frame: sometimes [ returns a data frame and sometimes it just returns a vector:
head(tib[[1]]) # is a vector
head(tib[,1])  # is a tibble
```

Another interesting feature of tibbles is that their columns can contain vectors, like usual, but also lists of any R objects like other tibbles, `nls()`{.R} object, etc. This is called "nesting":

```{r warning=FALSE, message=FALSE}
tib1 <- tibble(x=1:3, y=1:3)
tib2 <- tibble(x=1:5, y=1:5)
tib <- tibble(number=1:2, data=list(tib1, tib2))
tib
tib_unnested <- tib %>% unnest(data)
tib_unnested
tib_unnested %>% nest(data=c(number,y))
tib_unnested %>% nest(data=c(number,y)) %>% pull(data)
```



## Operations in the tidyverse

In the end, base R and the `tidyverse` package provide many efficient functions to perform most of the tasks you would want to perform recursively, thus allowing avoiding explicit for loops.

Here are some examples, and you will find much more [here](https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html). Take a look at the cheatsheets on [tidyr](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf) and on [dplyr](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf), it's really helpful. 

Note the use of the pipe operator, `%>%`{.R}, that allows a clear syntax for successive operations.

```{r, message=FALSE}
# Let's create a random tibble
library(tidyverse)
N <- 500
dt <- tibble(x     = rep(runif(N,-1,1),3), 
             y     = runif(N*3,-1,1), 
             signx = ifelse(x>0,"positive","negative"),
             signy = ifelse(y>0,"positive","negative")
)
dt
```

### Sampling data
```{r, message=FALSE}
dt %>% slice(1:3)  # by index
dt %>% sample_n(3) # randomly
```

### Operations on groups of a variable
`group_by(column)`{.R} groups by similar values of the wanted column(s) and performs the next operations on each element of the group successively.

```{r, message=FALSE}
dt %>% 
    group_by(signx) %>% 
    sample_n(3)
dt %>% 
    group_by(signx, signy) %>% 
    sample_n(3)
```

### Summary by groups of a variable
`summarise()`{.R} returns a single value for each element of the groups.

```{r, message=FALSE}
dt %>% 
    group_by(signx) %>% 
    summarise(count  = n(),
              mean_x = mean(x), 
              sd_x   = sd(x))
dt %>% 
    group_by(signx, signy) %>% 
    summarise(count  = n(),
              mean_x = mean(x), 
              mean_y = mean(y))
```

### Sorting

```{r, message=FALSE}
dt %>% arrange(x)
dt %>% arrange(x, desc(y))
```

### Merge tables column-wise

At least one column with the **exact** same name must be present in each table.
```{r, message=FALSE}
dt2 <- tibble(signx=c("positive","positive","negative","negative"), 
              signy=c("positive","negative","positive","negative"), 
              value=c(TRUE, FALSE, FALSE, TRUE))
dt2
inner_join(dt,dt2)
```

### Merge tables row-wise
This works even if there are missing rows.
```{r, message=FALSE}
dt3 <- tibble(a=1:3, b=3:5, c=6:8)
dt4 <- tibble(a=3:1, c=3:5)
bind_rows(dt3,dt4)
```

### Add/modify a column
`mutate()`{.R}, like `$`{.R}, adds a column if it doesn't exist, and modifies it if it does.
```{r, message=FALSE}
dt %>% mutate(w=seq_along(x), z=sin(x))
dt %>% mutate(x=seq_along(x))
```

### Selecting columns

```{r, message=FALSE}
dt %>% select(x)  # only x
dt %>% select(-x) # all but x
dt %>% select(starts_with("sign"))
dt %>% select(contains("x"))
```

### Filtering columns

```{r, message=FALSE}
dt %>% filter(signx=="positive")
dt %>% filter(x<0, y>.1) # multiple filters can be applied at once
```

### Reorder columns

```{r, message=FALSE}
dt %>% relocate(y, .after = signy)
```

### Separate columns

The separation is based on standard separators such as "-", "\_", ".", etc. A single separator can be specified with the argument "sep".

```{r, message=FALSE}
dt5 <- tibble(file=list.files(path="Exo/FTIR/Data/"))
dt5
dt5 %>% separate(file, c(NA, "sample", "temperature", NA), convert = TRUE)
dt5 %>% separate(file, 
                 c("name", "extension"), 
                 sep = "\\."
                 )
```

### Apply a function recursively on each element of a column

Take a look at the [cheatsheet on the `purrr` package](https://github.com/rstudio/cheatsheets/raw/master/purrr.pdf) for more options. I show here a use of `purrr::map(vector, ~function(.))`{.R} that returns a list, or its equivalent `purrr::map_dbl(vector, ~function(.))`{.R} that returns a vector of doubles. In case you need more parameters, you can use `purrr::map2(vector1, vector2, ~function(.x, .y))`{.R}, where `.x` and `.y` refer to `vector1` and `vector2`, respectively (it's always `.x` and `.y` whatever the name of `vector1` and `vector2`).

```{r, message=FALSE}
Lor <- function(x, x0=0, FWHM=1){
    2/(pi*FWHM)/( 1 + ((x-x0)/(FWHM/2))^2 )
}
dt6 <- tibble(file=list.files(path="Exo/spectro/Data/", pattern = ".txt")) %>% 
    mutate(data = map(file, 
                      ~read_table2(file.path("Exo/spectro/Data", .),
                                   col_names = c("w", "int"))
                      ),
           fit = map(data, ~nls(data=., 
                                int ~ y0+A1*Lor(w, w1, sd1)+A2*Lor(w, w2, sd2),
                                start=list(y0  = .1,
                                           A1  = max(.$int)*10, 
                                           A2  = max(.$int)*10,
                                           w1  = .$w[which.max(.$int)],
                                           w2  = .$w[which.max(.$int)]-30,
                                           sd1 = 10, sd2 = 10))
                     ),
           tidied = map(fit, broom::tidy),
           mean_int = map_dbl(data, ~mean(.$int))
           )
dt6
tibble(x=1:3, y=5:7) %>% 
    mutate(sum = map2_dbl(x, y, sum))
tibble(a=list(tibble(x=1:3, y=5:7), 
              tibble(x=0:3, y=4:7)), 
       b=list(tibble(x=10:13, y=15:18), 
              tibble(x=-1:2,  y=-14:-17))) %>% 
    mutate(sumx = map2_dbl(a, b, ~sum(.x$x, .y$x)),
           sumy = map2_dbl(a, b, ~sum(.x$y, .y$y)))
```

### Nesting and un-nesting data

```{r, message=FALSE}
dt7 <- dt6 %>% unnest(tidied)
dt7
# Nesting data per repeated values in a column (~equivalent to grouping)
dt7 %>% nest(data=-file)
dt7 %>% nest(data=-c(file, mean_int))
# This is equivalent to:
dt7 %>% 
    group_by(file, mean_int) %>% 
    summarise(data=list(tibble(data, fit, term, estimate, 
                               std.error, statistic, p.value)))
```

### Providing data to ggplot

```{r, message=FALSE}
library(ggplot2)
dt %>% filter(abs(y)> 0.1) %>% 
    ggplot(aes(x=x, y=y, color=signy))+
        geom_point()
```

## Exercises {#exo-df}

<details>
<summary>**Exercise 1**</summary>

- Create a 3 column `data.frame`{.R} containing 10 random values, their sinus, and the sum of the two first columns.
- Print the 4 first lines of the table
- Print the second column
- Print the average of the third column
- Using `plot(x,y)`{.R} where `x` and `y` are vectors, plot the 2nd column as a function of the first
- Look into the function `write.table()`{.R} to write a text file containing this `data.frame`{.R}
- Do the all the same things with a `tibble`{.R}

<details>
    <summary>Solution</summary>

```{r, warnings=FALSE}
# Create a 3 column `data.frame`{.R} containing 10 random values, their sinus, 
# and the sum of the two first columns.
x <- runif(10)
y <- sin(x)
z <- x + y
df <- data.frame(x=x, y=y, z=z)
# Print the 4 first lines of the table
head(df, 4)
# Print the second column
df[,2]
# Print the average of the third column
mean(df$z); mean(df[3]); mean(df[,3])
# Using `plot(x,y)`{.R} where `x` and `y` are vectors, 
# plot the 2nd column as a function of the first
plot(df[,1], df[,2])
plot(df$x, df$y)
# Look into the function `write.table()`{.R} to write a text file 
# containing this `data.frame`{.R}
write.table(df, "Data/some_data.dat", quote = FALSE, row.names = FALSE)
# # # # # # # # # # # # # # # # # 
# Tibble version
library(tidyverse)
df_tib <- tibble(a = runif(10), b = sin(a), c = a + b)
head(df_tib, 4)
df_tib[,2]; df_tib[[2]];
mean(df_tib$c); mean(df_tib[3]); mean(df_tib[,3]); mean(df_tib[[3]])
write.table(df_tib, "Data/some_data.dat", quote = FALSE, row.names = FALSE)
plot(df_tib$a, df_tib$b)
```

</details>
</details>


<details>
    <summary>**Exercise 2**</summary>

- Download the files:
    - <a href="Data/rubis_01.txt" download target="_blank">rubis_01.txt</a>
    - <a href="Data/population.csv" download target="_blank">population.csv</a>
    - <a href="Data/FTIR_rocks.xlsx" download target="_blank">FTIR_rocks.xlsx</a>
- Load them into separate `data.frames`{.R}. Look into the options of `read.table()`{.R}, `read.csv()`{.R}, `readxl::read_excel()`{.R},  to get the proper data fields.
- Print their dimensions and column names
- Add the appropriate names ("w", "intensity") to the data.frame containing rubis_01.txt. 

<details>
    <summary>Solution</summary>

```{r, warnings=FALSE}
rubis_01   <- read.table("Data/rubis_01.txt", col.names = c("w", "intensity"))
population <- read.csv("Data/population.csv")
FTIR_rocks <- readxl::read_excel("Data/FTIR_rocks.xlsx")
dim(rubis_01); names(rubis_01)
dim(population); names(population)
dim(FTIR_rocks); names(FTIR_rocks)
```

</details>
</details>


<details>
    <summary>**Exercise 3**: `data.frame`{.R} from a "complicated" data file</summary>

- Download the TGA data file <a href="Data/ATG.txt" download target="_blank">ATG.txt</a>
- Load it into a `data.frame`{.R}. Look into the options of `read.table()`{.R} to get the proper data fields.

<details>
    <summary>Solution</summary>

```{r}
d <- read.table("Data/ATG.txt", 
                skip=12,
                header=FALSE, 
                nrows=4088)
names(d) <- c("Index", "t", "Ts", "Tr", "Value")
head(d)
d <- read.table("Data/ATG.txt", 
                skip=10,
                comment.char="[",
                header=TRUE, 
                nrows=4088)
head(d)
```

</details>
</details>


<details>
    <summary>**Exercise 4**</summary>

- Create a `data.frame`{.R} (or a `tibble`{.R}) called `people` from <a href="Data/people.txt" download target="_blank">people.txt</a>. Try using the function `read.table` or its `tidyverse` equivalent `read_table2`.
- What are the column names of `people`?
- Add a column `age` and fill it with the appropriate values
    + *Bonus Tip:* to interactively enter the data, look into the function `readline()`{.R} and try making a `for` loop
- What is the average age of the class?
- How many students are in the class?
- What is the percentage of female/male students in the class?
- Get the columns 1 and 3
- Print `people` where you removed the rows 1, 5 and 6
- Get the columns of `age` and `origin` in another `data.frame`{.R}
- Subset `people` to get the list of people from China and Ukraine in one `data.frame`{.R}
- How many students come from the USA? from France?
- Order the `data.frame`{.R} `people` by student name
- Order the `data.frame`{.R} `people` by country of origin and then by age
- Select 5 random students from `people`
- Using the `tidyverse`, get the average age of females and males in the class in a `tibble`{.R}

</details>



<details>
<summary>**Exercise 5**</summary>

Download <a href="Data/population.csv" download target="_blank">population.csv</a> and load it into a `data.frame`{.R}.

- What are the names of the columns?
- Are the data tidy? make the table tidy if needed
- Create a subset containing the data for Montpellier
    + What is the max and min of population in this city?
    + The average population over time?
- What is the total population in 2012?
- What is the total population per year?
- What is the average population per city over the years?

<details>
<summary>Solution</summary>

```{r}
# Download population.txt and load it into a `data.frame`{.R}.
library(tidyverse)
popul <- read_csv("Data/population.csv")
# What are the names of the columns and the dimension of the table?
names(popul); dim(popul)
# Are the data tidy?
head(popul) # no
popul.tidy <- popul %>% 
    pivot_longer(cols=-year,
                 names_to = "city",
                 values_to = "pop"
                )
popul.tidy
# Create a subset containing the data for Montpellier
mtp <- subset(popul.tidy, city == "Montpellier")
# I prefer the tidyverse version
mtp <- popul.tidy %>% filter(city == "Montpellier")
# What is the max and min of population in this city?
max(mtp$pop)
min(mtp$pop)
range(mtp$pop)
# The average population over time?
mean(mtp$pop)
# What is the total population in 2012?
sum(popul.tidy[popul.tidy$year == 2012, "pop"])
popul.tidy %>% 
    filter(year==2012) %>% 
    select(pop) %>% 
    sum()
# What is the total population per year?
popul.tidy %>% 
    group_by(year) %>% 
    summarise(pop_tot=sum(pop))
# What is the average population per city over the years?
popul.tidy %>% 
    group_by(city) %>% 
    summarise(pop_ave=mean(pop))
```

</details>
</details>



<details>
    <summary>**Exercise 6:** tidy data wrangling</summary>

- First, load the `tidyverse` and `lubridate` package
- Load <a href="Data/people1.csv" download target="_blank">people1.csv</a> and <a href="Data/people2.csv" download target="_blank">people2.csv</a> into `pp1` and `pp2`
- Create a new tibble `pp` by using the pipe operator (`%>%`{.R}) and successively:
    - joining the two tibbles into one using `inner_join()`{.R}
    - adding a column `age` containing the age in years (use lubridate's `time_length(x, 'years')`{.R} with x a time difference in days) by using `mutate()`{.R}
- Display a summary of the table using `str()`{.R}
- Using `groupe_by()`{.R} and `summarize()`{.R}:
    - Show the number of males and females in the table (use the counter `n()`{.R})
    - Show the average age per gender
    - Show the average size per gender and institution
    - Show the number of people from each country, sorted by descending population (`arrange()`{.R})
- Using `select()`{.R}, display:
    - only the name and age columns
    - all but the name column
- Using `filter()`{.R}, show data only for
    - Chinese people
    - From institution ECL and UCBL
    - People older than 22 
    - People with a `e` in their name

<details>
    <summary>Solution</summary>

```{r, warnings=FALSE, message=FALSE}
# First, load the `tidyverse` and `lubridate` package
library(tidyverse)
library(lubridate)
# Load people1.csv and people2.csv
pp1  <- read_csv("Data/people1.csv")
pp2  <- read_csv("Data/people2.csv")
# Create a new tibble `pp` by using the pipe operator (`%>%`)
# and successively:
# - joining the two tibbles into one using `inner_join()`
# - adding a column `age` containing the age in years 
#   (use lubridate's `time_length(x, 'years')` with x a time
#   difference in days) by using `mutate()`
pp <- pp1 %>% 
        inner_join(pp2) %>% 
        mutate(age=time_length(today()-dateofbirth,'years'))
# Display a summary of the table using `str()`
str(pp)
# Using `groupe_by()` and `summarize()`:
# - Show the number of males and females in the table 
#   (use the counter `n()`)
pp %>% group_by(gender) %>% summarize(count=n())
# - Show the average age per gender
pp %>% group_by(gender) %>% summarize(age=mean(age))
# - Show the average size per gender and institution
pp %>% group_by(gender, institution) %>% summarize(size=mean(size))
# - Show the number of people from each country, 
#   sorted by descending population
pp %>% group_by(origin) %>% 
        summarize(count=n()) %>% 
        arrange(desc(count))
# Using `select()`, display:
# - only the name and age columns
pp %>% select(c(name, age))
# - all but the name column
pp %>% select(-name)
# Using `filter()`, show data only for
# - Chinese people
pp %>% filter(origin=='China')
# - From institution ECL and UCBL
pp %>% filter(institution %in% c('ECL', 'UCBL'))
# - People older than 22 
pp %>% filter(age>22)
# - People with a `e` in their name
pp %>% filter(grepl('e',name))
```


</details>
</details>

For more interesting exercises in the tidyverse, look at:

- [CO2 emissions: data wrangling and ggplot2](Exo/co2/exercise.html)
- [Religion and babies: data handling, ggplot2 and plotly](Exo/religion_babies/exercise.html)
- [COVID-19: data wrangling, ggplot2](Exo/covid/exercise.html)
- [Nanoparticles statistics from SEM images: data wrangling, ggplot2 and fitting](Exo/SEM_particles/exercise.html)

<br>
<br>
<br>
<br>
<br>





<br>
<br>
<br>
<br>
<br>


