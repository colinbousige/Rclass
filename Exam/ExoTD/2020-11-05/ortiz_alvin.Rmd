---
title : "R Exercises - COVID"
author: ALVIN JOHN ORTIZ
date  : "`r Sys.Date()`"
output: 
    html_document:
        toc            : true
        toc_float      : true
        toc_depth      : 4
        highlight      : tango
        number_sections: true
---


<style type="text/css">
blockquote {
  background: #E9F9FF;
  border-left: 5px solid #026086;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
  font-size: 1em;
}
</style>


The COVID-19 pandemics is a lot of bad things, but it's also a source of data to play with...

Here we're gonna use the data gathered by the John's Hopkins Hospital and published on [GitHub](https://github.com/CSSEGISandData/COVID-19), for [confirmed cases](https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv) and [deaths](https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv).

In case the links above die at some point, here is a version of these files as of April 21st, 2020:

- [confirmed cases](Data/time_series_covid19_confirmed_global.csv)
- [deaths](Data/time_series_covid19_deaths_global.csv)

In fact, a [quick lookup](https://www.statsandr.com/blog/top-r-resources-on-covid-19-coronavirus/#r-shiny-apps) on the Internet will now return plenty of versions for this data, with even cleaner (tidy) versions, including country population, etc. There are even R packages to get this.
The point here is to learn how to read a given dataset, clean it and use it, so we'll stay with the JHU dataset.


# Data wrangling

- First, load the `tidyverse` and `lubridate` packages

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, fig.asp=1.5}

library(tidyverse)
library(lubridate)

```

- Load the raw .csv files from the links above and store them in `confirmed_raw` and `deaths_raw`. You can provide `read_csv()`{.R} with an url. The numbers given in these tables are cumulative numbers of confirmed cases and deaths.

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, fig.asp=1.5}
urlConfirmed <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv"
urlDeaths <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv"

setwd("C:/Users/AJ Ortiz/Desktop/Nanoscale Engineering/R Practices")
deaths_raw <- read_csv("time_series_covid19_deaths_global.csv")
confirmed_raw <- read_csv("time_series_covid19_confirmed_global.csv")
deaths_raw
confirmed_raw

```

- Using successive operations with the pipe operator `%>%`{.R} create a function `tidyfy_jhh(df, name)`{.R}, that, given a tibble `df` (_i.e._, the data from JHH we just loaded), will:
    + Rename the columns `Province/State` and `Country/Region` to `state` and `country`
    + Remove the lines from the `Diamond Princess`
    + Remove the columns from `state`, `Lat` and `Long`
    + Make the table tidy by having 3 columns : `country`, `date` and `count`
    + Remove any duplicated lines
    + Using the `mdy()`{.R} function from the `lubridate` package, convert the `date` column to a R Date format
    + Some countries appear several times as their numbers are separated by provinces or states. Summarize the counts per country and per date as the total number of cases per country and per day. 
        + Give this column the name of the type of case we look at (confirmed or deaths, string that id provided in the `name` parameter of the function `tidyfy_jhh(df, name)`{.R}. For this, use the notation `summarize(!!sym(name):= your_result_here)`{.R} to tell R that `name` should be used as a column name)

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, fig.asp=1.5}

tidyfy_jhh <- function(df, name){
  
df %>% as_tibble() %>%
  rename(state = `Province/State`) %>%
  rename(region = `Country/Region`)


df %>% filter_all(any_vars(. %in% c('Diamond Princess')))
subset(df, !(state %in% c('Diamond Princess')) & !(region %in% c('Diamond Princess')))


df[ ,c('state', 'Lat', 'Long')] <- list(NULL)


df %>% select(region, "1/22/20":"11/2/20") %>% 
  pivot_longer(col = -region, names_to = 'date', values_to = 'count', names_transform = list(Year = as.numeric)) %>% 
  rename(country = `region`)


df <- which(duplicated(df[3]))
df <- df[-c(df),]
df

df <- df %>% mutate(date = mdy(date))
df


df %>% group_by(country,date) %>%
  summarize(count=sum(count))
df

}


deaths_raw <- tidyfy_jhh(deaths_raw):deaths_raw
#Renaming columns `Province/State` and `Country/Region` to `state` and `country`


deaths_raw <- deaths_raw %>% as_tibble() %>%
  rename(state = `Province/State`) %>%
  rename(region = `Country/Region`)
deaths_raw

confirmed_raw <- confirmed_raw %>% as_tibble() %>%
  rename(state = `Province/State`) %>%
  rename(region = `Country/Region`)
confirmed_raw

#Remove the lines from the `Diamond Princess`

deaths_raw %>% filter_all(any_vars(. %in% c('Diamond Princess'))); deaths_raw
deaths_raw <- subset(deaths_raw, !(state %in% c('Diamond Princess')) & !(region %in% c('Diamond Princess')))
deaths_raw

confirmed_raw %>% filter_all(any_vars(. %in% c('Diamond Princess'))); confirmed_raw
confirmed_raw <- subset(confirmed_raw, !(state %in% c('Diamond Princess')) & !(region %in% c('Diamond Princess')))
confirmed_raw

#Remove the columns from `state`, `Lat` and `Long`

deaths_raw[ ,c('state', 'Lat', 'Long')] <- list(NULL)
deaths_raw

confirmed_raw[ ,c('state', 'Lat', 'Long')] <- list(NULL)
confirmed_raw

#Make the table tidy by having 3 columns : `country`, `date` and `count`

deaths_raw <- deaths_raw %>% select(region, "1/22/20":"11/2/20") %>% 
  pivot_longer(col = -region, names_to = 'date', values_to = 'count', names_transform = list(Year = as.numeric)) %>% rename(country = `region`)
deaths_raw

confirmed_raw <- confirmed_raw %>% select(region, "1/22/20":"11/2/20") %>% 
  pivot_longer(col = -region, names_to = 'date', values_to = 'count', names_transform = list(Year = as.numeric)) %>% rename(country = `region`)
confirmed_raw

#Remove any duplicated lines

dup_deaths <- which(duplicated(deaths_raw))
dup_deaths
deaths_raw <- deaths_raw[-c(dup_deaths),]
deaths_raw

dup_confirmed <- which(duplicated(confirmed_raw))
dup_confirmed
confirmed_raw <- confirmed_raw[-c(dup_confirmed),]
confirmed_raw

#Using the `mdy()`{.R} function from the `lubridate` package, convert the `date` column to a R Date format

deaths_raw <- deaths_raw %>% mutate(date = mdy(date))
deaths_raw

confirmed_raw <- confirmed_raw %>% mutate(date = mdy(date))
confirmed_raw

#Summarize the counts per country and per date as the total number of cases per country and per day

library(dplyr)
library(tidyr)

deaths_sum <- deaths_raw %>% group_by(country,date) %>%
  summarize(count=sum(count))
deaths_sum

confirmed_sum <- confirmed_raw %>% group_by(country, date) %>%
  summarize(count=sum(count))
confirmed_sum


```

- Apply this function to the raw tibbles to get tidy `confirmed` and `deaths` tibbles.

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, fig.asp=1.5}

tidyfy_jhh <- function(df, name){
  
df %>% as_tibble() %>%
  rename(state = `Province/State`) %>%
  rename(region = `Country/Region`)


df %>% filter_all(any_vars(. %in% c('Diamond Princess')))
subset(df, !(state %in% c('Diamond Princess')) & !(region %in% c('Diamond Princess')))


df[ ,c('state', 'Lat', 'Long')] <- list(NULL)


df %>% select(region, "1/22/20":"11/2/20") %>% 
  pivot_longer(col = -region, names_to = 'date', values_to = 'count', names_transform = list(Year = as.numeric)) %>% 
  rename(country = `region`)


df <- which(duplicated(df[3]))
df <- df[-c(df),]
df

df <- df %>% mutate(date = mdy(date))
df


df %>% group_by(country,date) %>%
  summarize(count=sum(count))
df

}

```

> In case you didn't manage to get there, here are the csv files containing:
> 
> - [confirmed](Data/covid_confirmed.csv)
> - [deaths](Data/covid_deaths.csv)

Now, join these three tibbles in `alldata`, and successively:

- Add the columns `newcases` and `newdeaths` containing the number of new cases and deaths every day, as `confirmed` and `deaths` contain cumulative numbers. For this look into the `lag()`{.R} function.
- Filter rows to remove data for which the number of cases is lower than the minimum number of cases in China (for easier comparison). This day will be considered as `Day 1`.
- Add a `day` column containing the day number since `Day 1`.
- Filter rows to have only countries for which we have at least one week of data

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, fig.asp=1.5}

#Add the columns `newcases` and `newdeaths` containing the number of new cases and deaths every day, as `confirmed` and `deaths` contain cumulative numbers.

deaths_sum$newdeaths <- lag(lead(deaths_sum$count,1) - deaths_sum$count)
deaths_sum$newdeaths[deaths_sum$newdeaths < 0] <- 0
deaths_sum

confirmed_sum$newcases <- lag(lead(confirmed_sum$count,1) - confirmed_sum$count)
confirmed_sum$newcases[confirmed_sum$newcases < 0] <- 0
confirmed_sum

alldata <- cbind(deaths_sum,confirmed_sum)
alldata <- alldata[,-c(5,6)]
colnames(alldata) <- c("country","date","deaths","newdeaths","confirmed","newcases")
alldata

#Filter rows to remove data for which the number of cases is lower than the minimum number of cases in China (for easier comparison). This day will be considered as `Day 1`. Add a `day` column containing the day number since `Day 1`.

deaths_sumChina <- deaths_sum %>% filter_all(any_vars(. %in% c('China'))) %>% 
  group_by(date) %>% 
  summarize(count=sum(count)) %>% 
  mutate(day = row_number())
deaths_sumChina

min_china <- alldata %>%
  filter(country == "China")
min_china <- min_china$confirmed[1]
min_china

alldata <- alldata %>%
  filter(confirmed > min_china-1)
alldata

#Filter rows to have only countries for which we have at least one week of data


```

> In case you didn't manage to get there, [here is a csv file](Data/covid_alldata.csv) containing `alldata` so that you can continue with the exercise.


# Plotting

- Using `ggplot2`, plot (P1) **side by side** the number of **confirmed** cases and **deaths** vs time in 5 countries of your choice.
    - Using `ggrepel`, add the country names as annotation
    - Do the plot using linear scale, then a log scale

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, fig.asp=.8}

all_data <- read_csv("covid_alldata.csv")
all_data


library(ggplot2)
library(ggrepel)
library(patchwork)


deaths_plot <- all_data %>% filter(country == 'France'|
                                       country == 'Philippines'|
                                       country == 'Portugal'|
                                       country == 'Saudi Arabia'|
                                       country == 'Japan') %>%
  mutate(should_be_labeled = ifelse(day %in% "80",TRUE, FALSE))
deaths_plot

confirmed_plot <- all_data %>% filter(country == 'France'|
                                       country == 'Philippines'|
                                       country == 'Portugal'|
                                       country == 'Saudi Arabia'|
                                       country == 'Japan') %>%
  mutate(should_be_labeled = ifelse(day %in% "80",TRUE, FALSE))
confirmed_plot

plot1 <- deaths_plot %>% ggplot(aes(x=date, y=newdeaths, col=country)) +
  geom_line(alpha=0.5, size=1) +
  ggtitle("deaths") +
  labs(x="date",y="count") +
  theme_bw() +
  geom_label_repel(data = filter(deaths_plot, should_be_labeled == TRUE), (aes(label = country)))
plot1

plot2 <- confirmed_plot %>% ggplot(aes(x=date, y=newcases, col=country)) +
  geom_line(alpha=0.5, size=1) +
  ggtitle("confirmed") +
  labs(x="date", y="count") +
  theme_bw() +
  geom_label_repel(data = filter(deaths_plot, should_be_labeled == TRUE), (aes(label = country)))
plot2

covid_plot <- plot1 + plot2
covid_plot

```

- Plot (P2) the death ratio (*i.e.* deaths per confirmed cases) per country averaged over time as a barplot, for 50 random countries.
    + Try ordering the countries per decreasing ratio using `reorder()`{.R}
    + Flip the plot to have horizontal bars
    + Is there anything wrong?

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, fig.asp=1.7}


# Death Ratio for all countries
dratio <- data.frame(all_data[1:nrow(all_data),4]/all_data[1:nrow(all_data),3])
dratio
colnames(dratio) = "dratio"
# Binding Death Ratio to alldata as column
all_data <- cbind(all_data,data.frame(dratio))
# Getting mean value of death ratio per country
all_data

dratio_mean <- all_data %>%
  group_by(country) %>%
  summarise(dratio_mean=mean(dratio))
dratio_mean
# Choosing arbitrary row number
nranrow <-sample(1:nrow(dratio_mean), 
                 size=50,
                 replace=FALSE)
# Using those random row numbers to create random countries
ran_cont <- dratio_mean %>% slice(nranrow)
ran_cont
# Bar Plotting
ran_cont %>%
  ggplot(aes(x = reorder(country, dratio_mean), y = dratio_mean))+
  geom_bar(stat="identity", color='skyblue',fill='steelblue')+
  theme(axis.text.x=element_text(angle=45, hjust=1))+
  coord_flip()

```

- To better see the effect of confinement regulation, it's probably more interesting to plot the number of new confirmed cases. 
    - Plot as a barplot the number of new confirmed cases per day for 2 countries of your choice, and add a vertical line corresponding to the date of application of confinement rules. For example, in France and Italy it was on March 17th and March 10th, respectively.
    - Add a smooth line to smooth out the effect or irregular numbers reporting. You can play with the `span` parameter to have a more or less smooth curve.

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, fig.asp=1.5}

all_data

two_countries <- all_data %>% filter(country == 'France'|
                                       country == 'Philippines')
two_countries

two_countries %>%
  ggplot(aes(x = date, y = newcases, color = country)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=45, hjust=1)) +
  geom_vline(aes(xintercept = as.numeric(ymd("2020-03-17")))) +
  geom_vline(aes(xintercept = as.numeric(ymd("2020-03-14"))),color="green") +
  geom_smooth(n=500,span=.2,level=.4) +
  theme_classic()

```


# Fitting

+ Load the library `broom` ([vignette](https://cran.r-project.org/web/packages/broom/vignettes/broom.html)). `broom` allows tidying the output of fit functions such as `lm()` or `nls()`, taking the text output and making it into a tibble. Example:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}

library(broom)


```

Here, by combining `nest()` and `purrr::map()`, we can apply the fit to each group. The result is a tibble containing the fit result for each group. Then, using `broom`'s function `augment()` and `tidy()`, we respectively get the fitted values and residues, and the fitting parameters.

- Now then, using the same procedure as in the example above, fit the total Confirmed cases for the 5 countries you chose earlier **for the 100 first days** using a [logistic function](https://en.wikipedia.org/wiki/Logistic_function), and plot the data and their fit, and show the results of the fits.

```{r echo=params$solution, warning = FALSE, message=FALSE, cache=FALSE}

fit <- deaths_plot %>%
  group_by(nest(data=-country)) %>% 
  mutate(fit=map(data, ~ nls(data = .,
                             confirmed~A/(1+exp(-B*day)), 
                             start=list(A=50000, B=1))),
         tidied = map(fit, tidy),
         augmented = map(fit, augment))
fit
fit %>% unnest(augmented)
fit %>% unnest(tidied)
fit %>% unnest(tidied) %>% 
  select(country, term, estimate, std.error) %>% 
  pivot_wider(names_from = term, 
              values_from = c(estimate,std.error))
ggplot(data=subdata, aes(x=date, y=confirmed, col=country))+
    geom_point(alpha=0.5) + 
    geom_line(data=d_fit %>% unnest(augmented), 
        aes(x=x,y=.fitted, col=country))

```

In fact, this exponential model is rather wrong... A better model of epidemics dynamics is done by the SIR model, for Susceptible, Infectious, Recovered. A description of the SIR modeling through R can be found [here](https://staff.math.su.se/hoehle/blog/2020/03/16/flatteningthecurve.html), for example.
