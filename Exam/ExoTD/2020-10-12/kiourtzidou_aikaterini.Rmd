---
title : "R Exercises - Religion and babies"
date  : "`r Sys.Date()`"
output: 
    html_document:
        toc            : true
        toc_float      : true
        toc_depth      : 4
        highlight      : tango
        number_sections: true
        code_download  : FALSE
---


In these exercises we will see the power of the libraries `ggplot2` and `plotly` to make sense of statistical data. The goal is to reproduce the moving chart that you can see in this video from Hans Rosling -- I invite you to watch his other videos, they are quite enlightning and inspiring:

<div style="max-width:854px"><div style="position:relative;height:0;padding-bottom:56.25%"><iframe src="https://embed.ted.com/talks/hans_rosling_religions_and_babies" width="854" height="480" style="position:absolute;left:0;top:0;width:100%;height:100%" frameborder="0" scrolling="no" allowfullscreen></iframe></div></div>

<br>
<br>

For this, we will need to gather the data:

- From [Gapminder](https://www.gapminder.org/data/), data per country and per year from 1800 to 2018:
    - [The children per woman total fertility](Data_Religion/children_per_woman_total_fertility.csv)
    - [The income per capita](Data_Religion/income_per_person_gdppercapita_ppp_inflation_adjusted.csv)
    - [The total population](Data_Religion/population_total.csv)
- From the [PEW research center](https://www.pewforum.org/2015/04/02/religious-projection-table/2010/percent/all/), data per country:
    + [The religious composition](Data_Religion/religion.csv)

------- 

# Data handling

The first thing to do is to load and regroup all these datasets into a single one.

1. Load the `tidyverse` library and, using `read_csv()`, load the 4 datasets in 4 separate data.frames called `children`, `income`, `pop` and `religion`.

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
library(tidyverse)
children <- data.frame(read.csv("Data/children_per_woman_total_fertility.csv"))
colnames(children) <- gsub("X","",names(children),fixed = TRUE)
children

income <- data.frame(read.csv("Data/income_per_person_gdppercapita_ppp_inflation_adjusted.csv"))
colnames(income) <- gsub("X","",names(income),fixed = TRUE)
income

pop <- data.frame(read.csv("Data/population_total.csv"))
colnames(pop) <- gsub("X","",names(pop),fixed = TRUE)
pop

religion <- data.frame(read.csv("Data/religion.csv"))
religion
```

2. To reproduce the chart on the video, we need to determine the dominant religion in each country. In the `religion` dataset, add a column `Religion` that will give the name of the dominant religion for each country. For this, you might want to use this method that returns the name of the column containing the maximum of each row of a `data.frame`:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
colnames(religion)
dim(religion)
religion$Religion <- colnames(religion[,7:14])[max.col(religion[,7:14])]

religion

```

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}

```

3. Using `pivot_longer()`, make all datasets tidy. 

- `children` should now contain 3 columns: `Country`, `Year` and `Fertility`. 
- `income` should now contain 3 columns: `Country`, `Year` and `Income`. 
- `pop` should now contain 3 columns: `Country`, `Year` and `Population`. 

We will only consider data from 1800 to 2018. Example of syntax using the pipe operator `%>%`:

```{r}
children <- children %>% 
    select(Country, '1800':'2018') %>% 
    pivot_longer(col=-Country,
                 names_to="Year", 
                 values_to="Fertility",
                 names_transform=list(Year = as.numeric))
children

income <- income %>% 
    select(Country, '1800':'2018') %>% 
    pivot_longer(col=-Country,
                 names_to="Year", 
                 values_to="Income",
                 names_transform=list(Year = as.numeric))
income


pop <- pop %>% 
    select(Country, '1800':'2018') %>% 
    pivot_longer(col=-Country,
                 names_to="Year", 
                 values_to="Population",
                 names_transform=list(Year = as.numeric))
pop

```
The line `names_transform=list(Year = as.numeric)` is here to convert the character year values to numerical values.

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}

```

4. Now we want to combine all these datasets into a single one called `dat`, containing the columns `Country`, `Year`, `Population`, `Religion`, `Fertility` and `Income`. Look into the `inner_join()` function of the `dplyr` library (which is part of the `tidyverse` library). For the `religion` dataset, we will consider that the proportions of 2010 are representative of all times.

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
library(dplyr)


Religion <- tibble (religion %>% select(Country,Religion))
Religion

dat <- inner_join(inner_join(children,income),inner_join(pop,Religion))

dat <- dat %>%
    group_by(Country,Year,Fertility,Income,Population,Religion) %>%
    summarise()
dat
    
    
    




```

Now our dataset is ready, let's plot it.

# Plotting

1. Load the library `ggplot2` and set the global theme to `theme_bw()` using `theme_set()`

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}

library(ggplot2)
theme_set(theme_bw())

```

2. Create a subset of `dat` concerning your origin country. For me it will be `dat_france`

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}

dat_greece <- dat %>% 
                 filter(Country=="Greece")
dat_greece
                
```

3. Plot the evolution of the income per capita and the number of children per woman as a function of the years, and make it look like that (notice the kinks during the two world wars):

```{r echo=TRUE, warning = FALSE, message=FALSE, cache=FALSE}

p1 <- dat_greece %>%
    ggplot(aes(x=Year,y=Income))+labs(x="Year",y="Household income per capita per year [constant $]") + ggtitle("Household income in Greece") + geom_vline(xintercept = 1945,color="grey",size=4,alpha=0.6) + geom_vline(xintercept = 1918,color="grey",size=3,alpha=0.6)  + geom_point(alpha=0.3,size=5) + geom_smooth()


p2 <-dat_greece %>%
    ggplot(aes(x=Year,y=Fertility))+labs(x="Year",y="Children per woman") + ggtitle("Fertility in Greece")  + geom_line (size=2,colour="red") + geom_vline(xintercept = 1923,color="grey",size=5,alpha=0.6) + geom_vline(xintercept = 1880,color="grey",size=4,alpha=0.6) 
p1
p2



```

4. Create a subset of `dat` containing the data for your country plus all the neighbor countries (if you come from an island, the nearest countries...). For me, `dat_france_region` will contain data from France, Spain, Italy, Switzerland, Germany, Luxembourg and Belgium.

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}

library(dplyr)

dat_greece_region <- dat %>%
             filter(Country=="Greece" | Country=="Bulgaria" | Country =="Turkey" | Country=="Albania")
dat_greece_region

```

5. Plot again income and fertility as a function of the years, but add a color corresponding to the country and a point size to its population:

```{r echo=TRUE, warning = FALSE, message=FALSE, cache=FALSE}

p3 <- dat_greece_region %>%
        ggplot(aes(x=Year,y=Income,size=Population)) +
          geom_point(aes(color=Country)) +
          labs(x="Year",y="Household income per capita per year [constant $]") +
           ggtitle("Household income in Greece")+ 
            geom_vline(xintercept = 1945,color="grey",size=4,alpha=0.6)+ 
            geom_vline(xintercept = 1918,color="grey",size=3,alpha=0.6) 
    
p3


p4 <-dat_greece_region %>%
    ggplot(aes(x=Year,y=Fertility,size=Population))+
    geom_point(aes(color=Country))+
    labs(x="Year",y="Children per woman") + 
    ggtitle("Fertility in Greece")  + 
    geom_vline(xintercept = 1923,color="grey",size=5,alpha=0.6) + 
    geom_vline(xintercept = 1880,color="grey",size=4,alpha=0.6) 
    

p4
```

6. Load the library `plotly` and make the previous graphs interactive. You can make an interactive graph by calling `ggplotly()`, like that:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}

library(plotly)

P <- ggplot(data = dat_greece, aes(x=Population, y=Income)) +
        geom_point() 
ggplotly(P)

```

7. Finally, you can add a slider to the interactive graph allowing selecting a value for another variable (just like in the video) by adding the keyword `frame =` in the chart's aesthetics. So now, make the graph of the video ! (you can also add the aesthetics `id=Country` to show the country name in the popup when hovering on a point).


```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
final <- ggplot(data = dat_greece_region, aes(x=Population, y=Income, color =Country))+
     geom_point(aes(frame = Country)) 
ggplotly(final)

```
