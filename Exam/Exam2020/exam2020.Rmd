---
title : "Reproducible data treatment with R -- Exam"
author: Colin Bousige
date  : "01/12/2020"
output: 
    bookdown::pdf_document2: 
        toc            : false
        number_sections: false
        fig_caption    : true
        fig_number     : true
header-includes:
   - \usepackage{cmbright}
   - \usepackage{amssymb}
params: 
    solution:
        value: false
---

# Global setup (1 point)

- Unzip the `Exam_2020.zip`{.R} file somewhere on the computer, and rename the Rmd file as *name_firstname.Rmd*. You will work in this Rmd file and send it to me by email at the end, at **colin.bousige@univ-lyon1.fr**. Change the name of the author in the YAML header to your own name, but don't touch anything else. You will get a bonus if the file you sent me can be knitted without error.
- Load the libraries `tidyverse`{.R} and `broom` and set the global `ggplot2`{.R} theme to `theme_bw()`{.R}.

```{r include=params$solution, include=FALSE, warning = FALSE, cache=FALSE}
library(tidyverse)
library(broom)
theme_set(theme_bw())
```

---

# Exercise 1 - Correlation and causation (5 points)

- Load in a tibble the `Data/correlation.csv`{.R} file. It contains the per capita consumption of mozarella cheese and the number of people who died by falling down the stairs as a function of the years (source: [Spurious Correlations](http://www.tylervigen.com/spurious-correlations)).

```{r include=params$solution, warning=FALSE, message=FALSE}
d <- read_csv("Data/correlation.csv")
```

- Using `cor()`{.R}, compute the correlation between the number of people who died by falling down the stairs as a function of the per capita consumption of mozarella cheese.

```{r include=params$solution, warning=FALSE, message=FALSE}
cor(d[[2]], d[[3]])
```

- Plot the number of people who died by falling down the stairs as a function of the per capita consumption of mozarella cheese. Make the axis labels pretty, add the correlation value as the title, and add a linear fit.

```{r include=params$solution, warning=FALSE, message=FALSE}
ggplot(d, aes(x=per_capita_consumption_of_mozarella_cheese, 
              y=people_who_died_by_falling_down_the_stairs))+
    geom_point(size=5, alpha=.5)+
    geom_smooth(method="lm")+
    labs(x="Per capita consumption of mozarella cheese",
         y="People who died by falling down the stairs")+
    ggtitle(paste("Correlation:",round(cor(d[[2]], d[[3]]),2)))
```

- Do you think that *correlation* implies *causation* for these two datasets?


---

## Exercise 2 - Experimental data (14 points)

In this exercise we will recursively treat some x-ray diffraction (XRD) data obtained during a high-pressure experiment at the ESRF (the synchrotron in Grenoble). In this experiment, we measured the XRD patterns as a function of the pressure for two samples of the same rock, nicknamed *PY02*. PY02 is a pyrobitumen, *i.e.* some coal-like amorphous and porous carbon structure. The goal was to measure the *bulk modulus* $\kappa$ of this rock, defined as:
$$\frac{1}{\kappa}=-\frac{1}{V}\frac{\partial V}{\partial P}.$$
The bulk modulus characterizes the volume reduction of a sample as a function of the applied pressure, it's unit being a pressure unit (usually in the GPa range).

The bulk modulus is usually obtained during a high pressure experiment thanks to the Murnaghan equation of state:

$$
\frac{V}{V_0}=\left(1+P\frac{\kappa'}{\kappa}\right)^{-1/\kappa'}
$$
where $V$ is the volume of the unit cell, $V_0$ the volume at ambient pressure, and $\kappa'$ is the pressure derivative of $\kappa$. In first approximation, we will consider that $\kappa'$ is constant and that $\kappa'\simeq4$.

- Define the `Murnaghan(P, K, Kp)`{.R} function that, given the pressure $P$, the bulk modulus $K$ and its derivative $Kp$ (defaulting to $Kp=4$), returns the relative volume $\frac{V}{V_0}$

```{r include=params$solution, warning=FALSE, message=FALSE}
Murnaghan <- function(P, K, Kp=4){
    (1+P*Kp/K)^(-1/Kp)
}
```

- Find in the `Data`{.R} folder all the files containing the experimental diffraction patterns. They are under the form `PY02_Pxx.dat`{.R} or `PY02bis_Pxx.dat`{.R}. Store this list of files in a vector called `flist`{.R}.

```{r include=params$solution, warning=FALSE, message=FALSE}
flist  <- list.files(path="Data", pattern = "_P")
```

- Read and store the two files containing the pressures of each run, `PY02_pressures.dat`{.R} and `PY02bis_pressures.dat`{.R}. Combine these two tables into a single tidy one called `Pressures`{.R}, containing three columns `run`{.R}, `P.kbar`{.R} and `sample`{.R}.

```{r include=params$solution, warning=FALSE, message=FALSE}
PY02_P    <- read_table2("Data/PY02_pressures.dat")
PY02bis_P <- read_table2("Data/PY02bis_pressures.dat")
PY02bis_P$sample <- "PY02bis"
PY02_P$sample    <- "PY02"
Pressures <- bind_rows(PY02_P,PY02bis_P)
```


- Define the `get_run(flist)`{.R} function that, given **a vector** of file names, returns **a vector** of the run number of the corresponding files. The output pressure must be given in **GPa**. The files are under the form `PY02_Pxx.dat` or `PY02bis_Pxx.dat`, where `xx` is the  run number.

```{r include=params$solution, warning=FALSE, message=FALSE}
get_run <- function(flist){
    run  <- gsub("PY02_P","",flist)
    run  <- gsub("PY02bis_P","",run)
    as.numeric(gsub(".dat","",run))
}
```

- Define the `get_sample(flist)`{.R} function that, given **a vector** of file names, returns the names of the samples (*i.e.* PY02 or PY02bis, *i.e.* the text before the first occurrence of the "\_" character). For this, you will want to split the file names according to the "\_" character (use `strsplit()`{.R}), make the result a vector using `unlist()`{.R}, and take every other two elements of the resulting vector.

```{r include=params$solution, warning=FALSE, message=FALSE}
get_sample <- function(flist){
    all <- unlist(strsplit(flist, "_"))
    all[seq_along(all) %% 2 == 1]
}
```

- Define the `norm01(x)`{.R} function that given a vector, returns this vector normalized to [0,1]

```{r include=params$solution, warning=FALSE, message=FALSE}
norm01 <- function(x) {(x-min(x))/(max(x)-min(x))}
```

- Now let's read all the data files in `flist` and store the result in a tidy `tibble` with three columns, `file`, `q` and `int` (the data files containing the diffracted intensity as a function of the scattering vector $q$). Either use a `for loop` or the `tidyverse`-friendly version using `purrr::map()`{.R} (+1 bonus for this version). Add the `int_n` column containing the normalized intensity for each file.

```{r include=params$solution, warning=FALSE, message=FALSE}
d <- tibble(file=flist) %>% 
    mutate(data=map(file, ~ read_table2(file.path("Data",.), 
                               col_names=c("q","int")))) %>% 
    unnest(data) %>% 
    group_by(file) %>% 
    mutate(int_n=norm01(int))
```

- Plot all the normalized diffractograms on top of each other, with lines of a different color for each file, and define nice axis labels, such as *Scattering Vector q [1/Å]* and *Intensity [arb. units]*.

```{r include=params$solution, warning=FALSE, message=FALSE}
d %>%
    ggplot(aes(x=q, y=int_n+as.numeric(factor(file))-1, color=file))+
        geom_line()+
        labs(x = "Scattering Vector q [1/Å]", 
             y = "Intensity [arb. units]")
```

- We are interested in the position of the first peak around $q=1.8$ Å$^{-1}$. Create the `pospeak` tibble that stores the position `Q` of the maximum of each diffractogram. 
    - Make sure to filter data for scattering vectors below 2.5 Å$^{-1}$. 
    - We will also add the `dQ` column that stores the error on the value of `Q`. We will estimate it as the average value of the difference between each neighbor value of `q`.
    - Add the columns `run` and `sample` that contain the run number and sample name for each file (using the two functions defined above).
    - Finally, order the tibble by ascending run for each sample

```{r include=params$solution, warning=FALSE, message=FALSE}
pospeak <- d %>% 
    filter(q<2.5) %>% 
    group_by(file) %>% 
    summarise(Q  = q[which.max(int)],
              dQ = mean(diff(q))) %>% 
    mutate(run    = get_run(file),
           sample = get_sample(file)) %>% 
    arrange(sample, run)
```

- Now join this table together with the `Pressures` one in order to get the sample names and pressures in this table. Finally, add the new column `P` containing the pressure in GPa (1 GPa = 10 kbar).

```{r include=params$solution, warning=FALSE, message=FALSE}
pospeak <- pospeak %>% 
    inner_join(Pressures) %>% 
    mutate(P=P.kbar/10)
```

In case you didn't manage to get there, I provide in the exam .Rmd file the expected `pospeak` table so that you can continue with the exercise.

```{r include=FALSE, warning=FALSE, message=FALSE}
pospeak <- read_table2("file    Q    dQ    run    sample    P.kbar    P
PY02_P1.dat       1.802587    0.003839376    1       PY02     0.00 0.000
PY02_P2.dat       1.840981    0.003839376    2       PY02     2.40 0.240
PY02_P3.dat       1.875535    0.003839376    3       PY02     8.80 0.880
PY02_P4.dat       1.875535    0.003839376    4       PY02    15.90 1.590
PY02_P5.dat       1.890893    0.003839376    5       PY02    27.75 2.775
PY02_P6.dat       1.929286    0.003839376    6       PY02    36.00 3.600
PY02_P7.dat       1.936965    0.003839376    7       PY02    40.00 4.000
PY02_P8.dat       1.971520    0.003839376    8       PY02    51.00 5.100
PY02_P9.dat       1.902411    0.003839376    9       PY02    23.00 2.300
PY02_P10.dat      1.867856    0.003839376   10       PY02     7.50 0.750
PY02_P11.dat      1.802587    0.003839376   11       PY02     0.10 0.010
PY02bis_P1.dat    1.821784    0.003839376    1    PY02bis     0.00 0.000
PY02bis_P2.dat    1.883214    0.003839376    2    PY02bis     3.00 0.300
PY02bis_P3.dat    1.883214    0.003839376    3    PY02bis    16.00 1.600
PY02bis_P4.dat    1.933126    0.003839376    4    PY02bis    38.00 3.800
PY02bis_P5.dat    1.971520    0.003839376    5    PY02bis    48.00 4.800")
```

- We now need to estimate the volume variation and the error on its measurement. Normally, we would need to get the crystal lattice volume, but as mentioned earlier, the PY02 sample is an amorphous rock, and thus it has no crystalline order. In first approximation, we can consider that the volume reduction is linked to the interactomic distance reduction through:
$$
\frac{V}{V_0}=\left(\frac{r}{r_0}\right)^3,
$$
where $r$ is the most representative interatomic distance (*i.e.* the one whose Fourier transform will have the highest intensity), the scattering vector $q$ being linked to the distance $r$ by $q=2\pi/r$. In our case, $r \simeq 2\pi/1.8\simeq 3.5$ Å is the distance between two graphitic-like planes.
Using this, add to the `pospeak` tibble the columns `VV0` and `dVV0` containing, respectively, the volume reduction and an estimation of its measurement error. 
    - Make sure that the `V0` part refers to the value at ambient pressure (*i.e.* $P=0$). 
    - Make sure you propagate the errors in a proper way.

```{r include=params$solution, warning=FALSE, message=FALSE}
pospeak <- pospeak %>% 
    group_by(sample) %>% 
    mutate(VV0=(Q[P==0]/Q)^3,
          dVV0=3*(dQ[P==0]/Q[P==0] + dQ/Q))
```

- Fit the Murnaghan equation of state to the experimental data. Make sure to add an amplitude parameter $A$ (that should be close to 1) to allow for more leeway on the fit. We fix the derivative value $Kp=4$.

```{r include=params$solution, warning=FALSE, message=FALSE}
fit <- nls(data = pospeak,
           VV0 ~ A*Murnaghan(P, K),
           start = list(A=1, K=1))
```

- Store the resulting values of $K$ and it's fitting standard error $dK$ in two variables. Round the values to the appropriate floating number. You may use the `broom::tidy()`{.R} function.

```{r include=params$solution, warning=FALSE, message=FALSE}
K <- round(tidy(fit) %>% filter(term=="K") %>% .$estimate,0)
dK <- round(tidy(fit) %>% filter(term=="K") %>% .$std.error,0)
```

- Finally, make the plot of the experimental points (a color per sample) and the fit. Make it look like so:

```{r echo=params$solution, warning=FALSE, message=FALSE}
pospeak %>%
    ggplot(aes(x=P, y=VV0))+
        geom_point(alpha=0.5, aes(color=sample))+
        geom_errorbar(alpha=0.5, aes(color=sample, ymin=VV0-dVV0, ymax=VV0+dVV0))+
        geom_line(data=augment(fit2), aes(x=P, y=.fitted), color="royalblue", lty=2)+
        labs(x="Pressure [GPa]",
             y="V/V0")+
        scale_color_manual(values = c("black","red"), name="Sample")+
        ggtitle(paste("Murnaghan fit: K = (your value) ± (your value) GPa"))+
        theme(legend.position = c(.9,.85))
```



