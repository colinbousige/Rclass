# 3D color plots {#colorplots}

You may want to plot your data as a color map, like the evolution of a Raman spectrum as a function of temperature, pressure or position. In some cases you'll have a 3-columns `data.frame` with x, y, and z values (_e.g._ intensity of a peak as a function of the position on the sample), in some cases you can have a list of spectra evolving with a given parameter. 

## The ggplot2 solution

Let's create a dummy set of spectra that we will gather in a tidy `tibble`.

```{r, message=FALSE}
Nspec <- 40                           # Amount of spectra
T     <- seq(273, 500, length=Nspec)  # Fake Temperatures
N     <- 500                          # Size of the x vector
library(tidyverse)
library(ggplot2)
library(plotly)
fake_data <- tibble()                 # Empty tibble
for (i in 1:Nspec) {
    # Let's create dummy x and y values
    # You would normally use a read.table here 
    x  <- seq(0, 100, length = N)
    y  <- 50*dnorm(x, mean= (T[i]/T[1])*20 + 25, sd = 10+runif(1,max=5) )
    fake_data <- bind_rows(fake_data, 
                           tibble(w=x, Intensity=y, T=T[i]) 
                           )
}
fake_data
```

OK, so now we have some fake experimental data stored in a tidy `tibble` called `fake_data`. We want to plot it as a color map in order to grasp the evolution of the spectra:

```{r, out.width='100%', message = FALSE, fig.asp=.7,cache=FALSE}
# Plotting
colors <- colorRampPalette(c("white","royalblue","seagreen",
                             "orange","red","brown"))(500)
P1 <- ggplot(data=fake_data, aes(x=w, y=T, fill=Intensity)) + 
          geom_raster() + #geom_tile would work
          ggtitle("Some fake data") + 
          scale_fill_gradientn(colors=colors,name="Intensity\n[arb. units]") +
          labs(x = "Fake Raman Shift [1/cm]",
               y = "Fake Temperature [K]") +
          theme_bw()
ggplotly(P1, dynamicTicks = TRUE)
# Some other way : a stacking of plots 
colors <- colorRampPalette(c("royalblue","seagreen","orange",
                             "red","brown"))(length(T))
fake_data$T_round <- round(fake_data$T,1)
P2 <- ggplot(data=fake_data, 
                aes(x=w, 
                    y=Intensity+as.numeric(factor(T))-1,
                    color = factor(T_round), group = T, 
                    text = paste("w =",round(w,3),
                               "<br>Int =",round(Intensity,3),
                               "<br>T =",round(T,3))
                    )
                ) + 
          geom_line() + 
          labs(x = "Fake Raman Shift [1/cm]", 
               y = "Fake Intensity [arb. units]") +
          coord_cartesian(xlim = c(25,75)) +
          scale_color_manual(values=colors,name="Fake\nTemperature [K]") +
          theme_bw()
ggplotly(P2, tooltip = "text", dynamicTicks = TRUE)
P3 <- ggplot(data=fake_data, 
                aes(x=w, 
                    y=Intensity+as.numeric(factor(T))-1, 
                    color=T, group=T,
                    text=paste("w =",round(w,3),
                               "<br>Int =",round(Intensity,3),
                               "<br>T =",round(T,3)))) + 
          geom_line() + 
          labs(x="Fake Raman Shift [1/cm]", y="Fake Intensity [arb. units]") +
          scale_color_gradientn(colors=colors,name="Fake\nTemperature [K]") +
          coord_cartesian(xlim = c(25,75)) +
          theme_bw()
ggplotly(P3, tooltip = "text", dynamicTicks = TRUE)
```



## The base graphics solution

In some cases you end up with a matrix _z_, and two vectors _x_ and _y_. This is easy to plot using the base `image` function. For the sake of example, let's just use the `acast` function on our melted 3-columns data.frame:

```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.6,cache=FALSE}
library(reshape2)
z <- acast(data.frame(fake_data), x~T, value.var="Intensity")
x <- unique(data.frame(fake_data)[,"w"])
y <- unique(data.frame(fake_data)[,"T"])
x <- x[order(x)]
y <- y[order(y)]
colors <- colorRampPalette(c("white","royalblue","seagreen","orange","red","brown"))(500)
par(mar=c(4, 4, .5, 4), lwd=2)
image(x,y,z,col = colors)
```
You can add a legend by using the `image.plot` function:
```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.6,cache=FALSE}
library(fields)
par(mar=c(4, 4, .5, 4), lwd=2)
image.plot(x,y,z, col = colors)
```


## The plotly solution

And finally, if you want to make this an interactive plot, you can use `plotly`:
```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.6,cache=FALSE}
library(plotly)
aX <- list(title = "Raman Shift [1/cm]")
aY <- list(title = "Temperature [K]")
# Weird but you need to use t(z) here:
z <- t(z)
# Color plot
plot_ly(x=x,y=y,z=z,type = "heatmap",colors=colors) %>% 
   layout(xaxis = aX, yaxis = aY)
```
Or, very cool, an interactive surface plot:
```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.9,cache=FALSE}
plot_ly(x=x,y=y,z=z,type = "surface",colors=colors) %>%
   layout(scene = list(xaxis = aX, yaxis = aY, dragmode="turntable"))
```


## The case of non-regular data

In case you have a set of non-regular data, plotting it as a color map can get tricky: how do we tell the plotting device what color should be in a place where there is no data point?

The solution is to use a spline (or linear, but spline looks usually nicer) interpolation of your 2D data. For this, we can use the `akima` package and its `interp()` function, like so:


```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
# let's make our data irregular and see the plot is now not working:
fake_data_irreg <- fake_data[sample(nrow(fake_data), nrow(fake_data)/3),]
# let's plot these irregular data
colors <- colorRampPalette(c("white","royalblue","seagreen",
                             "orange","red","brown"))(500)
ggplot(data=fake_data_irreg, aes(x=w, y=T, fill=Intensity)) + 
      geom_raster() + #geom_tile would work
      ggtitle("Some irregular and ugly fake data") + 
      scale_fill_gradientn(colors=colors,name="Intensity\n[arb. units]") +
      labs(x = "Fake Raman Shift [1/cm]",
           y = "Fake Temperature [K]") +
      theme_bw()
# now let's interpolate the data on a regular grid
library(akima)
fake_data_irreg.interp <- with(fake_data_irreg, 
    interp(x = w, y = T, z = Intensity, 
           duplicate="median",
           xo=seq(min(fake_data_irreg$w), max(fake_data_irreg$w), length = 100),
           yo=seq(min(fake_data_irreg$T), max(fake_data_irreg$T), length = 100),
           extrap=FALSE, linear=FALSE)
    )
# fake_data_irreg.interp is a list of 2 vectors and a matrix
str(fake_data_irreg.interp)
# Regrouping this list to a 3-columns data.frame
melt_x <- rep(fake_data_irreg.interp$x, times=length(fake_data_irreg.interp$y))
melt_y <- rep(fake_data_irreg.interp$y, each=length(fake_data_irreg.interp$x))
melt_z <- as.vector(fake_data_irreg.interp$z)
fake_data_irreg.smooth <- na.omit(data.frame(w=melt_x, T=melt_y, Intensity=melt_z))
# Plotting
fake_data_irreg.smooth %>% 
    ggplot(aes(x=w, y=T, fill=Intensity)) + 
        geom_raster() + 
        ggtitle("Some irregular fake data that have been spline-interpolated") + 
        scale_fill_gradientn(colors=colors, name="Intensity\n[arb. units]") +
        labs(x = "Fake Raman Shift [1/cm]", 
             y = "Fake Temperature [K]") +
        theme_bw()
```




## 2D density of points

In case you want to plot a density of points, you have a variety of solutions:
```{r}
df <- tibble(x=rnorm(1e3, mean=c(1,5)),
             y=rnorm(1e3, mean=c(5,1)))
p1 <- ggplot(data=df, aes(x=x,y=y))+ geom_density2d() + ggtitle('geom_density2d()')
p2 <- ggplot(data=df, aes(x=x,y=y))+ geom_hex() + ggtitle('geom_hex()')
p3 <- ggplot(data=df, aes(x=x,y=y))+ geom_bin2d() + ggtitle('geom_bin2d()')
p4 <- ggplot(data=df, aes(x=x,y=y))+ ggtitle('stat_density2d()') +
        stat_density2d(aes(fill = ..density..), geom = "tile", contour = FALSE, n = 200) +
        scale_fill_continuous(low = "white", high = "dodgerblue4")
library(cowplot)
plot_grid(p1,p2,p3,p4)
```


Or the base `smoothScatter()` function could do the trick:
```{r}
smoothScatter(df)
```





