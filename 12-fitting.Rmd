# Fitting

## Linear fitting

```{r include=FALSE, warning = FALSE, message=FALSE, cache=FALSE}
rm(list = ls())
library(ggplot2)
library(patchwork)
```

Let's learn how to do simple fits with R and plot the results.
```{r, warnings=FALSE}
# Create some fake data
d <- read.table(header=TRUE,text="
   x           y
   39.11       6.67
   46.1        10.8
   52.02       16.36
   56.07       23.16
   61.00       26.5
   65.26       31.3
   69.16       33.5
   74.00       41.0
   81.70       50.3
   ")
# Fit with a linear model
fit <- lm(y~x, data=d)
# Summary of the fit
summary(fit)
attributes(fit)
# Retrieve the coefficients and errors
coef(fit); coef(fit)[1]; coef(fit)['(Intercept)']
summary(fit)$coefficients; summary(fit)$coefficients["x","Std. Error"]
# Plotting the points and the fit
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, .5, .5), lwd=2, las=1)
plot(d, pch=16)
abline(coef(fit), col="red")
to_print <- paste("y = ", round(coef(fit)[1],2)," + x*",
                    round(coef(fit)[2],2), sep="")
text(50, 50, to_print)
library(ggplot2)
theme_set(theme_bw())
ggplot(data=d, aes(x,y)) + 
    geom_point(cex=3) +
    geom_smooth(method="lm") +
    annotate("text", x = 50, y = 50, label = to_print)
```

The function `geom_smooth()` will fit the data and display the fitted line, but to retrieve the actual coefficients you still need to run `lm()`.


## Nonlinear Least Squares fitting

### The `nls` workhorse

You can fit data with your own functions and constraints using [`nls`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/nls). Example:


```{r, warnings=FALSE}
# Create fake data
x  <- seq(-7,7,.1)
y  <- dnorm(x, sd = .5) + dnorm(x, mean=2, sd = 1) + runif(length(x))/10
df <- data.frame(x=x,y=y)
ggplot(data=df, aes(x,y))+
    geom_point()+
    ggtitle("Some fake data we want to fit with 2 Gaussians")
# Create a function to fit the data
myfunc <- function(x, y0, x0, A, B) {
    y0 + dnorm(x, sd=A) + dnorm(x, mean=x0, sd=B)
}
# Fit the data using a user function
fit <- nls(y ~ myfunc(x, y0, x0, A, B),
           data=df,
           start=list(y0=0, x0=1.5, A=.2, B=.2) # provide starting point
           )
summary(fit)
coef(fit)
# Plotting the resulting function in red
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, .5, .5), lwd=2, las=1)
plot(x, y, pch=16, ylim=c(0,1.1))
lines(x, predict(fit), col="red", lwd=2)
```

Or with `ggplot2`:

```{r}
P1 <- ggplot(data=df, aes(x,y))+
    ggtitle("Retrieving the fit performed beforehand")+
    geom_point(size=2, alpha=.5) +
    geom_line(aes(y=predict(fit)), color="red", size=1)
P2 <- ggplot(data=df, aes(x,y))+
    ggtitle("Doing the fit directly withing ggplot2")+
    geom_point(size=2, alpha=.5) +
    geom_smooth(method = "nls", 
                method.args = list(formula = y ~ myfunc(x, y0, x0, A, B),
                                   start=list(y0=0, x0=1.5, A=.2, B=.2)
                                   ), 
                data = df,
                se = FALSE,
                color="red")
P1/P2
```

### Using constraints

In `nls` it is even possible to constraint the fitting by adding lower and upper boundaries. You have to be careful with these and not provide stupid ones, *e.g.*:

```{r, warnings=FALSE}
# Constraining the upper and lower values of the fitting parameters
fit2 <- nls(y~ myfunc(x, y0, x0, A, B),
           start=list(y0=0, x0=5, A=.2, B=.2),
           upper=list(y0=Inf, x0=Inf, A=.4, B=1),
           lower=list(y0=-Inf, x0=4, A=-Inf, B=-Inf),
           algorithm = "port"
           )
# Plotting the resulting function in blue
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, 2, .5), lwd=2, las=1)
plot(x, y, pch=16, ylim=c(0,1.1), main="Beware of constraints")
lines(x, predict(fit2), col="royalblue", lwd=2)
```


### A more robust version of `nls`

Sometimes, `nls` will struggle to converge towards a solution, especially if you provide initial guesses that are too far from the expected values.

```{r warning=FALSE, message=FALSE, error=TRUE}
fit3 <- nls(y~ myfunc(x, y0, x0, A, B),
           start=list(y0=-10, x0=500, A=10000, B=2000)
           )
```

In that case, you may want to use a more robust `nls` function such as `nlsLM` from the `minpack.lm` package.

```{r warning=FALSE, message=FALSE}
library(minpack.lm)
fit3 <- nlsLM(y~ myfunc(x, y0, x0, A, B),
           start=list(y0=-10, x0=500, A=10000, B=2000)
           )
summary(fit);
summary(fit3);
```


## The broom library


Thanks to the [`broom`](https://cran.r-project.org/web/packages/broom/vignettes/broom.html) library, it is easy to retrieve all the fit parameters in a `tibble`:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
x  <- seq(-7,7,.1)
y  <- dnorm(x, sd = .5) + dnorm(x, mean=2, sd = 1) + runif(length(x))/10
df <- data.frame(x=x,y=y)
# Create a function to fit the data
myfunc <- function(x, y0, x0, A, B) {
    y0 + dnorm(x, sd=A) + dnorm(x, mean=x0, sd=B)
}
# Fit the data using a user function
fit <- nls(y ~ myfunc(x, y0, x0, A, B),
           data=df,
           start=list(y0=0, x0=1.5, A=.2, B=.2) # provide starting point
           )
library(broom)
# Get all parameters and their error
tidy(fit)
# Get the fitted curve and residuals
augment(fit)
```

It is then easy to make a recursive fit on your data without using a `for loop`:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, error=TRUE}
library(broom)
library(tidyverse)
library(ggplot2)
theme_set(theme_bw())
# Create fake data
a <- seq(-10,10,.1)
centers <- runif(3, min=-8, max=8)
widths  <- runif(3, min=0.5, max=1)
amp     <- runif(3, min=2, max=10)
noise   <- .3*runif(length(a))-.15
d <- tibble(x=rep(a,3),
            y=c(amp[1]*dnorm(a,mean=centers[1],sd=widths[1]) + sample(noise),
                amp[2]*dnorm(a,mean=centers[2],sd=widths[2]) + sample(noise),
                amp[3]*dnorm(a,mean=centers[3],sd=widths[3]) + sample(noise)),
            T=rep(1:3, each=length(a))
            )
# Plot the data
d %>% ggplot(aes(x=x, y=y, color=factor(T)))+
        geom_line()
# Fit all data
d_fitted <- d %>% 
    nest(data=-T) %>%
    mutate(fit = purrr::map(data, ~ nls(data = .,
                                y ~ y0 + A*dnorm(x, mean=x0, sd=FW), 
                                start=list(A  = max(.$y),
                                           y0 = .01, 
                                           x0 = .$x[which.max(.$y)], 
                                           FW = .7)
                                )),
           tidied = purrr::map(fit, tidy),
           augmented = purrr::map(fit, augment)
          )
d_fitted
# data and fit resulting curve
d_fitted %>% 
  unnest(augmented)
# fit parameters
d_fitted %>% 
  unnest(tidied)
# fit parameters as a tidy table
d_fitted %>% 
  unnest(tidied) %>% 
  select(T, term, estimate, std.error) %>% 
  pivot_wider(names_from = term, 
              values_from = c(estimate,std.error))
# plot fit result
d_fitted %>% 
    unnest(augmented) %>% 
    ggplot(aes(x=x, color=factor(T)))+
        geom_point(aes(y=y), alpha=0.5, size=3) + 
        geom_line(aes(y=.fitted))
```

In case you want to provide fit parameters that vary depending on the group you are looking at, use the notation `.$column_name`, like is done above.




## Exercises {#exo-fits}

<details>
    <summary>**Exercise 1**</summary>

- Load <a href="Data/exo_fit.txt" download target="_blank">exo_fit.txt</a> in a `data.frame`.
- Using `lm` or `nls` fit each column as a function of `x` and display the "experimental" data and the fit on the same graph.
    + Tip: Take a look at the function `dnorm` to define a Gaussian

<!-- ```{r}
x <- seq(-10,10,.1)
y <- 4*x+6+runif(length(x))*5
z <- 100*dnorm(x, mean=2.1,sd=2)+runif(length(x)) -.5
w <- sin(x/1.5)+runif(length(x))/2 -.5/2
u <- sin(x/1.5)+x*.2+runif(length(x))/5 -.5/5
df <- data.frame(x=x, y=y, z=z, w=w, u=u)
write.table(df, "Data/exo_fit.txt", quote=FALSE, row.names=FALSE)
``` -->


</details>


<details>
    <summary>**Exercise 2: application to real data**</summary>

- Load the Raman spectrum <a href="Data/rubis_01.txt" download target="_blank">rubis_01.txt</a>, normalize it to [0,1] and plot it
- Define the Lorentzian function
- Guess grossly the initial parameters and plot the resulting curve as a blue dashed line
- Fit the data by a sum of 2 Lorentzians using `nls`
- Add the result on the plot as a red line
- Add the 2 Lorentzian components as area-filled curves with `alpha=0.2` and two different colors


<details>
    <summary>Solution</summary>

```{r, warnings=FALSE, error=TRUE}
library(tidyverse)
# Load rubis_1.txt, normalize it to [0,1] and plot it
d <- read_table2("Data/rubis_01.txt", col_names=c("w", "Int"))
norm01 <- function(x) {(x-min(x))/(max(x)-min(x))}
d$Int_n <- norm01(d$Int)
P <- d %>%
    ggplot(aes(x=w, y=Int_n))+
        geom_point(alpha=0.5)
P
# Define the Lorentzian function
Lorentzian <- function(x, x0=0, FWHM=1){
    2/(pi*FWHM)/( 1 + ((x-x0)/(FWHM/2))^2 )
}
# Guess grossly the initial parameters and plot the resulting curve as a blue dashed line
P+geom_line(aes(y=.03 + 
                    3*Lorentzian(w, x0=3160, FWHM=10) +
                    7*Lorentzian(w, x0=3210, FWHM=10)),
            col="blue", lty=2)
# Fit the data by a sum of 2 Lorentzians using `nls`
fit <- nls(data=d, Int_n ~ y0 +
                    A1*Lorentzian(w,x1,FWHM1)+
                    A2*Lorentzian(w,x2,FWHM2), 
           start=list(y0=0.03,
                      x1=3160, FWHM1=10, A1=3,
                      x2=3200, FWHM2=10, A2=7)
           )
summary(fit)
# Add the result on the plot as a red line
P + geom_line(aes(y=.03 + 
                    3*Lorentzian(w, x0=3160, FWHM=10) +
                    7*Lorentzian(w, x0=3210, FWHM=10)),
            col="blue", lty=2)+
    geom_line(aes(y=predict(fit)), col="red")
# Add the 2 Lorentzian components as area-filled curves with `alpha=0.2` and two different colors
y0   <- coef(fit)['y0']
lor1 <- coef(fit)['A1']*Lorentzian(d$w,x0=coef(fit)['x1'],FWHM=coef(fit)['FWHM1'])
lor2 <- coef(fit)['A2']*Lorentzian(d$w,x0=coef(fit)['x2'],FWHM=coef(fit)['FWHM2'])
P + geom_line(aes(y=.03 + 
                    3*Lorentzian(w, x0=3160, FWHM=10) +
                    7*Lorentzian(w, x0=3210, FWHM=10)),
            col="blue", lty=2)+
    geom_line(aes(y=predict(fit)), col="red")+
    geom_area(aes(y=lor1), fill="royalblue", alpha=.2)+
    geom_area(aes(y=lor2), fill="orange", alpha=.2)
# Or, more compact:
# dd <- data.frame(d, ytot=lor1+lor2+y0,lor1=lor1+y0, lor2=lor2+y0)
# ggplot(data=dd, aes(x=w))+
#     labs(x="Raman Shift [1/cm]", y="Intensity [arb. units]")+
#     geom_point(aes(y=Int_n), alpha=.5)+
#     geom_line(aes(y=ytot), col="red")+
#     geom_area(aes(y=lor1), fill="royalblue", alpha=.2)+
#     geom_area(aes(y=lor2), fill="orange", alpha=.2)+
#     theme_bw()
```

</details>
</details>






<br>
<br>
<br>
<br>
<br>



