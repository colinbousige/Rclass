# Fitting

## Linear fitting

```{r include=FALSE, warning = FALSE, message=FALSE, cache=FALSE}
rm(list = ls())
```

Let's learn how to do simple fits with R and plot the results.
```{r, warnings=FALSE}
# Create some fake data
d <- read.table(header=TRUE,text="
   x           y
   39.11       6.67
   46.1        10.8
   52.02       16.36
   56.07       23.16
   61.00       26.5
   65.26       31.3
   69.16       33.5
   74.00       41.0
   81.70       50.3
   ")
# Fit with a linear model
fit <- lm(y~x, data=d)
# Summary of the fit
summary(fit)
attributes(fit)
# Retrieve the coefficients and errors
coef(fit); coef(fit)[1]; coef(fit)['(Intercept)']
summary(fit)$coefficients; summary(fit)$coefficients["x","Std. Error"]
# Plotting the points and the fit
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, .5, .5), lwd=2, las=1)
plot(d, pch=16)
abline(coef(fit), col="red")
to_print <- paste("y = ", round(coef(fit)[1],2)," + x*",
                    round(coef(fit)[2],2), sep="")
text(50, 50, to_print)
library(ggplot2)
ggplot(data=d, aes(x,y)) + 
    geom_point(cex=3) +
    geom_smooth(method="lm") +
    annotate("text", x = 50, y = 50, label = to_print)
```

The function `geom_smooth()` will fit the data and display the fitted line, but to retrieve the actual coefficients you still need to run `lm()`.


## Non linear fitting


You can fit data with your own functions and constraints using `nls`. Example:


```{r, warnings=FALSE}
# Create fake data
x  <- seq(-7,7,.1)
y  <- dnorm(x, sd = .5) + dnorm(x, mean=2, sd = 1) + runif(length(x))/10
df <- data.frame(x=x,y=y)
# Create a function to fit the data
myfunc <- function(x, y0, x0, A, B) {
    y0 + dnorm(x, sd=A) + dnorm(x, mean=x0, sd=B)
}
# Fit the data using a user function
fit <- nls(y ~ myfunc(x, y0, x0, A, B),
           data=df,
           start=list(y0=0, x0=1.5, A=.2, B=.2) # provide starting point
           )
summary(fit)
coef(fit)
# Plotting the resulting function in red
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, .5, .5), lwd=2, las=1)
plot(x, y, pch=16, ylim=c(0,1.1))
lines(x, predict(fit, x), col="red", lwd=2)
```

Or with `ggplot2`:

```{r}
ggplot(data=df, aes(x,y))+
    geom_point() +
    geom_smooth(method = "nls", 
                method.args = list(formula = y ~ myfunc(x, y0, x0, A, B),
                                   start=list(y0=0, x0=1.5, A=.2, B=.2)
                                   ), 
                data = df,
                se = FALSE,
                color="red")
```

In `nls` it is even possible to constraint the fitting by adding lower and upper boundaries. You have to be careful with these and not provide stupid ones, *e.g.*:

```{r, warnings=FALSE}
# Constraining the upper and lower values of the fitting parameters
fit2 <- nls(y~ myfunc(x, y0, x0, A, B),
           start=list(y0=0, x0=5, A=.2, B=.2),
           upper=list(y0=Inf, x0=Inf, A=.4, B=1),
           lower=list(y0=-Inf, x0=4, A=-Inf, B=-Inf),
           algorithm = "port"
           )
# Plotting the resulting function in blue
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, 2, .5), lwd=2, las=1)
plot(x, y, pch=16, ylim=c(0,1.1), main="Beware of constraints")
lines(x, predict(fit2, x), col="royalblue", lwd=2)
```

## The broom library


Thanks to the [`broom`](https://cran.r-project.org/web/packages/broom/vignettes/broom.html) library, it is easy to retrieve all the fit parameters in a `tibble`:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
x  <- seq(-7,7,.1)
y  <- dnorm(x, sd = .5) + dnorm(x, mean=2, sd = 1) + runif(length(x))/10
df <- data.frame(x=x,y=y)
# Create a function to fit the data
myfunc <- function(x, y0, x0, A, B) {
    y0 + dnorm(x, sd=A) + dnorm(x, mean=x0, sd=B)
}
# Fit the data using a user function
fit <- nls(y ~ myfunc(x, y0, x0, A, B),
           data=df,
           start=list(y0=0, x0=1.5, A=.2, B=.2) # provide starting point
           )
library(broom)
# Get all parameters and their error
tidy(fit)
# Get the fitted curve and residuals
augment(fit)
```

It is then easy to make a recursive fit on your data without using a `for loop`:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, error=TRUE}
library(broom)
library(tidyverse)
library(ggplot2)
# Create fake data
a <- seq(-10,10,.2)
centers <- runif(3, min=-8, max=8)
widths  <- runif(3, min=0.5, max=1)
amp     <- runif(3, min=2, max=10)
noise   <- .3*runif(length(a))-.15
d <- tibble(x=rep(a,3),
            y=c(amp[1]*dnorm(a,mean=centers[1],sd=widths[1]) + noise,
                amp[2]*dnorm(a,mean=centers[2],sd=widths[2]) + noise,
                amp[3]*dnorm(a,mean=centers[3],sd=widths[3]) + noise),
            T=factor(rep(1:3, each=length(a)))
            )
# Plot the data
d %>% ggplot(aes(x=x, y=y, color=T))+
        geom_point()
# Fit all data
d_fitted <- d %>% 
    nest(data=-T) %>%
    mutate(fit = purrr::map(data, ~ nls(data = .,
                                 y ~ y0 + A*dnorm(x, mean=x0, sd=FW), 
                                 start=list(A  = max(.$y),
                                            y0 = .01, 
                                            x0 = .$x[which.max(.$y)], 
                                            FW = .7)
                                 )),
           tidied = purrr::map(fit, tidy),
           augmented = purrr::map(fit, augment)
          )
# data and fit resulting curve
d_fitted %>% 
  unnest(augmented)
# fit parameters
d_fitted %>% 
  unnest(tidied)
# fit parameters as a tidy table
d_fitted %>% 
  unnest(tidied) %>% 
  select(T, term, estimate, std.error) %>% 
  pivot_wider(names_from = term, 
              values_from = c(estimate,std.error))
# plot fit result
d_fitted %>% 
    unnest(augmented) %>% 
    ggplot(aes(x=x, color=T))+
        geom_point(aes(y=y), alpha=0.5, size=3) + 
        geom_line(aes(y=.fitted))
```

In case you want to provide fit parameters that vary depending on the group you are looking at, use the notation `.$column_name`, like is done above.




## Exercises

<details>
    <summary>**Exercise 1**</summary>

- Load <a href="Data/exo_fit.txt" download target="_blank">exo_fit.txt</a> in a `data.frame`.
- Using `lm` or `nls` fit each column as a function of `x` and display the "experimental" data and the fit on the same graph.
    + Tip: Take a look at the function `dnorm` to define a Gaussian

<!-- ```{r}
x <- seq(-10,10,.1)
y <- 4*x+6+runif(length(x))*5
z <- 100*dnorm(x, mean=2.1,sd=2)+runif(length(x)) -.5
w <- sin(x/1.5)+runif(length(x))/2 -.5/2
u <- sin(x/1.5)+x*.2+runif(length(x))/5 -.5/5
df <- data.frame(x=x, y=y, z=z, w=w, u=u)
write.table(df, "Data/exo_fit.txt", quote=FALSE, row.names=FALSE)
``` -->


</details>


<details>
    <summary>**Exercise 2: application to real data**</summary>

- Load the Raman spectrum <a href="Data/rubis_01.txt" download target="_blank">rubis_01.txt</a>, normalize it to [0,1] and plot it
- Define the Lorentzian function
- Create a function that is the sum of 2 Lorentzians
- Guess grossly the initial parameters and plot the resulting curve as a blue dashed line
- Fit the data by a sum of 2 Lorentzians using `nls`
- Add the result on the plot as a red line
- Add the 2 Lorentzian components as area-filled curves with `alpha=0.2` and two different colors (see the function `polygon()`)
- Do the same plot with `ggplot2`


<details>
    <summary>Solution</summary>

```{r, warnings=FALSE, error=TRUE}
# Load rubis_1.txt, normalize it to [0,1] and plot it
d <- read.table("Data/rubis_01.txt", header=FALSE, col.names=c("w", "Int"))
norm01 <- function(x) {(x-min(x))/(max(x)-min(x))}
d$Int_n <- norm01(d$Int)
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, 2, .5), lwd=2, las=1)
plot(d$w, d$Int_n)
# Define the Lorentzian function
Lorentzian <- function(x,x0=0,FWHM=1,A=1,y0=0){
    y0 + 2*A/(pi*FWHM)/( 1 + ((x-x0)/(FWHM/2))^2 )
}
# Create a function that is the sum of 2 Lorentzians
Lor2 <- function(x,y0,x1,FWHM1,A1,x2,FWHM2,A2){
    y0 + Lorentzian(x,x0=x1,FWHM=FWHM1,A=A1,y0=0) + 
         Lorentzian(x,x0=x2,FWHM=FWHM2,A=A2,y0=0) 
}
# Guess grossly the initial parameters and plot the resulting curve as a blue dashed line
plot(d$w, d$Int_n)
lines(d$w,Lor2(d$w,y0=0.03, x1=3160, FWHM1=10, A1=3, 
                   x2=3210, FWHM2=10, A2=7), col="blue", lty=2)
# Fit the data by a sum of 2 Lorentzians using `nls`
fit <- nls(data=d, Int_n ~ Lor2(w,y0,x1,FWHM1,A1,x2,FWHM2,A2), 
           start=list(x1=3160, FWHM1=10, A1=3, y0=0.03,
                      x2=3200, FWHM2=10, A2=7)
           )
summary(fit)
# Add the result on the plot as a red line
lines(d$w, predict(fit, d$w), col="red")
# Add the 2 Lorentzian components as area-filled curves with `alpha=0.2` and two different colors
y0   <- coef(fit)['y0']
lor1 <- Lorentzian(d$w,x0=coef(fit)['x1'],FWHM=coef(fit)['FWHM1'],A=coef(fit)['A1'],y0=0)
lor2 <- Lorentzian(d$w,x0=coef(fit)['x2'],FWHM=coef(fit)['FWHM2'],A=coef(fit)['A2'],y0=0)
polygon(d$w, lor1+y0,col=adjustcolor("royalblue", alpha=.2), border=NA)
polygon(d$w, lor2+y0,col=adjustcolor("orange", alpha=.2), border=NA)
# Do the same plot with `ggplot2`
library(ggplot2)
dd <- data.frame(d, ytot=lor1+lor2+y0,lor1=lor1+y0, lor2=lor2+y0)
ggplot(data=dd, aes(x=w))+
    labs(x="Raman Shift [1/cm]", y="Intensity [arb. units]")+
    geom_point(aes(y=Int_n), alpha=.5)+
    geom_line(aes(y=ytot), col="red")+
    geom_area(aes(y=lor1), fill="royalblue", alpha=.2)+
    geom_area(aes(y=lor2), fill="orange", alpha=.2)+
    theme_bw()
```

</details>
</details>






<br>
<br>
<br>
<br>
<br>



